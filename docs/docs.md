## Shogun-D3: Decentralized Messaging Library

Shogun-D3 is a decentralized messaging library based on [Gun](https://gun.eco) and integrated with [ShogunCore](https://github.com/scobru/shogun-core). This documentation describes the functions available in the browser implementation (d3.js).

## Architecture

Shogun-D3 uses [Gun](https://gun.eco) as the underlying decentralized database and [ShogunCore](https://github.com/scobru/shogun-core) for authentication management. Messages are end-to-end encrypted using public/private keys generated with Gun's SEA (Security, Encryption, Authorization).

Users are identified by their Ethereum addresses, and messages are stored in unique "namespaces" generated by combining the addresses of the conversation participants.

## Initialization

```js
// The Shogun-D3 instance is globally available as window.d3 after loading d3.js
// You also need to include gun.js, sea.js, ethers.js, and shogun-core.js
```

## Authentication and Wallet Management

<dl>
<dt><a href="#getProvider">getProvider()</a> ⇒ <code>Promise.&lt;ethers.providers.Web3Provider&gt;</code></dt>
<dd><p>Gets the Web3 provider (MetaMask) if available.</p>
</dd>
<dt><a href="#connectWithMetaMask">connectWithMetaMask()</a> ⇒ <code>Promise.&lt;Object&gt;</code></dt>
<dd><p>Connects the user using MetaMask and authenticates with ShogunCore.</p>
</dd>
<dt><a href="#backupKeypair">backupKeypair(password)</a> ⇒ <code>Promise.&lt;string&gt;</code></dt>
<dd><p>Backs up the user's cryptographic keys.</p>
</dd>
<dt><a href="#restoreKeypair">restoreKeypair(backupData, password)</a> ⇒ <code>Promise.&lt;boolean&gt;</code></dt>
<dd><p>Restores the user's cryptographic keys from a backup.</p>
</dd>
</dl>

## Message Management

<dl>
<dt><a href="#sendMessage">sendMessage(payload, to, gunKeypair)</a> ⇒ <code>Promise.&lt;Object&gt;</code></dt>
<dd><p>Sends an encrypted message to one or more recipients.</p>
</dd>
<dt><a href="#receiveMessage">receiveMessage(recipientAddress, callback)</a> ⇒ <code>Promise.&lt;Function&gt;</code></dt>
<dd><p>Starts listening for messages sent to/from a specific address.</p>
</dd>
<dt><a href="#stopReceiveMessage">stopReceiveMessage(recipientAddress)</a> ⇒ <code>boolean</code></dt>
<dd><p>Stops listening for messages for a specific address.</p>
</dd>
<dt><a href="#decryptMessage">decryptMessage(messageData, gunKeypair)</a> ⇒ <code>Promise.&lt;string&gt;</code></dt>
<dd><p>Decrypts a received message.</p>
</dd>
</dl>

## Encryption and Key Management

<dl>
<dt><a href="#createSharedSecret">createSharedSecret(recipientPubKey, senderKeyPair)</a> ⇒ <code>Promise.&lt;string&gt;</code></dt>
<dd><p>Creates a shared secret between sender and recipient for message encryption.</p>
</dd>
<dt><a href="#encryptMessage">encryptMessage(message, secret)</a> ⇒ <code>Promise.&lt;string&gt;</code></dt>
<dd><p>Encrypts a message using a shared secret.</p>
</dd>
<dt><a href="#getKeypair">getKeypair(address)</a> ⇒ <code>Promise.&lt;Object&gt;</code></dt>
<dd><p>Retrieves the public part of a user's keypair.</p>
</dd>
<dt><a href="#registerKeypair">registerKeypair(address, keypair)</a> ⇒ <code>Promise.&lt;void&gt;</code></dt>
<dd><p>Registers a user's public keys in the Gun database.</p>
</dd>
</dl>

## Utilities

<dl>
<dt><a href="#HashNamespace">HashNamespace(string)</a> ⇒ <code>string</code></dt>
<dd><p>Encodes a string in base64, used to generate namespaces for conversations.</p>
</dd>
<dt><a href="#createLogger">createLogger()</a> ⇒ <code>Object</code></dt>
<dd><p>Creates a logger to track operations and errors.</p>
</dd>
<dt><a href="#dbConf">dbConf</a> ⇒ <code>Object</code></dt>
<dd><p>Gun database configuration.</p>
</dd>
</dl>

<a name="getProvider"></a>

## getProvider() ⇒ <code>Promise.&lt;ethers.providers.Web3Provider&gt;</code>
Gets the Web3 provider (MetaMask) if available.

**Returns**: <code>Promise.&lt;ethers.providers.Web3Provider&gt;</code> - Ethers provider connected to MetaMask, or null if not available.

**Example**
```js
const provider = await window.d3.getProvider();
if (provider) {
  const address = await provider.getSigner().getAddress();
  console.log("User address:", address);
}
```

<a name="connectWithMetaMask"></a>

## connectWithMetaMask() ⇒ <code>Promise.&lt;Object&gt;</code>
Connects the user using MetaMask and authenticates with ShogunCore.

**Returns**: <code>Promise.&lt;Object&gt;</code> - Object containing the user's address and Gun keypair.

| Property | Type | Description |
| --- | --- | --- |
| address | <code>string</code> | User's Ethereum address |
| keypair | <code>Object</code> | User's Gun keypair (contains pub, epub, priv, epriv) |

**Example**
```js
try {
  const { address, keypair } = await window.d3.connectWithMetaMask();
  console.log("User connected:", address);
} catch (error) {
  console.error("Connection error:", error.message);
}
```

<a name="backupKeypair"></a>

## backupKeypair(password) ⇒ <code>Promise.&lt;string&gt;</code>
Backs up the user's cryptographic keys.

**Returns**: <code>Promise.&lt;string&gt;</code> - Backup string containing the encrypted keys.

| Param | Type | Description |
| --- | --- | --- |
| password | <code>string</code> | Password to encrypt the backup |

**Example**
```js
const password = "secure-password";
const backupData = await window.d3.backupKeypair(password);
console.log("Backup data:", backupData);
// Save backupData in a secure location
```

<a name="restoreKeypair"></a>

## restoreKeypair(backupData, password) ⇒ <code>Promise.&lt;boolean&gt;</code>
Restores the user's cryptographic keys from a backup.

**Returns**: <code>Promise.&lt;boolean&gt;</code> - True if the restoration was successful, otherwise false.

| Param | Type | Description |
| --- | --- | --- |
| backupData | <code>string</code> | Previously generated backup string |
| password | <code>string</code> | Password used to encrypt the backup |

**Example**
```js
const backupData = "..."; // Previously saved backup data
const password = "secure-password";
const success = await window.d3.restoreKeypair(backupData, password);
if (success) {
  console.log("Keypair successfully restored");
}
```

<a name="sendMessage"></a>

## sendMessage(payload, to, gunKeypair) ⇒ <code>Promise.&lt;Object&gt;</code>
Sends an encrypted message to one or more recipients.

**Returns**: <code>Promise.&lt;Object&gt;</code> - Result of the operation.

| Property | Type | Description |
| --- | --- | --- |
| sent | <code>boolean</code> | True if the sending was successful |
| encrypted | <code>string</code> | Encrypted version of the message (if successful) |
| key | <code>string</code> | Gun key of the message (if successful) |
| namespace | <code>string</code> | Gun namespace where the message was saved (if successful) |
| why | <code>Error</code> | Error (if sending failed) |

| Param | Type | Description |
| --- | --- | --- |
| payload | <code>string</code> | Text of the message to send |
| to | <code>Array.&lt;string&gt;</code> | Array of Ethereum addresses of recipients |
| gunKeypair | <code>Object</code> | Gun keypair of the sender |

**Example**
```js
// Assuming the user is already connected and gunKeyPair is available
const message = "Hello, this is a test message!";
const recipient = "0x1234..."; // Recipient's Ethereum address
const result = await window.d3.sendMessage(message, [recipient], window.gunKeyPair);

if (result.sent) {
  console.log("Message sent successfully!");
} else {
  console.error("Error sending message:", result.why);
}
```

<a name="receiveMessage"></a>

## receiveMessage(recipientAddress, callback) ⇒ <code>Promise.&lt;Function&gt;</code>
Starts listening for messages sent to/from a specific address.

**Returns**: <code>Promise.&lt;Function&gt;</code> - Function to stop listening.

| Param | Type | Description |
| --- | --- | --- |
| recipientAddress | <code>string</code> | Ethereum address of the sender/recipient |
| callback | <code>function</code> | Function called when a new message arrives |

**Callback Parameters**:
- `messageData` <code>Object</code>: Message data
  - `decrypted` <code>string</code>: Decrypted content of the message
  - `isSentByMe` <code>boolean</code>: True if the message was sent by the current user
  - `timestamp` <code>number</code>: Message timestamp
  - `sender` <code>string</code>: Address of the sender
  - `messageKey` <code>string</code>: Unique key of the message
  - `originalData` <code>Object</code>: Original message data from Gun

**Notes**:
- Duplicate messages are automatically filtered using a caching system
- Messages older than 30 minutes are periodically removed from the cache

**Example**
```js
// Start listening for messages to/from the specified address
const recipientAddress = "0x1234...";
const cleanupFn = await window.d3.receiveMessage(recipientAddress, (messageData) => {
  const { decrypted, isSentByMe, timestamp, sender } = messageData;
  console.log(`New message from ${sender}: ${decrypted}`);
  console.log(`Sent by me: ${isSentByMe}`);
  console.log(`Time: ${new Date(timestamp).toLocaleString()}`);
});

// To stop listening later:
cleanupFn();
// or:
window.d3.stopReceiveMessage(recipientAddress);
```

<a name="stopReceiveMessage"></a>

## stopReceiveMessage(recipientAddress) ⇒ <code>boolean</code>
Stops listening for messages for a specific address.

**Returns**: <code>boolean</code> - True if a listener was stopped, false otherwise.

| Param | Type | Description |
| --- | --- | --- |
| recipientAddress | <code>string</code> | Ethereum address to stop listening for |

**Example**
```js
const recipientAddress = "0x1234...";
const stopped = window.d3.stopReceiveMessage(recipientAddress);
if (stopped) {
  console.log("Listening stopped successfully");
} else {
  console.log("No active listener to stop");
}
```

<a name="decryptMessage"></a>

## decryptMessage(messageData, gunKeypair) ⇒ <code>Promise.&lt;string&gt;</code>
Decrypts a received message.

**Returns**: <code>Promise.&lt;string&gt;</code> - Decrypted content of the message.

| Param | Type | Description |
| --- | --- | --- |
| messageData | <code>Object</code> | Message data from Gun |
| gunKeypair | <code>Object</code> | Gun keypair of the current user |

**Notes**:
- The function handles different message formats, checking for encryptedMSG, text, message, content, and raw_payload fields

**Example**
```js
// This is generally used internally, but can be called manually
window.gun.get(namespace).once(async (data, key) => {
  if (key !== '_' && data.encryptedMSG) {
    try {
      const decrypted = await window.d3.decryptMessage(data, window.gunKeyPair);
      console.log("Decrypted message:", decrypted);
    } catch (error) {
      console.error("Error decrypting:", error);
    }
  }
});
```

<a name="createSharedSecret"></a>

## createSharedSecret(recipientPubKey, senderKeyPair) ⇒ <code>Promise.&lt;string&gt;</code>
Creates a shared secret between sender and recipient for message encryption.

**Returns**: <code>Promise.&lt;string&gt;</code> - Shared secret.

| Param | Type | Description |
| --- | --- | --- |
| recipientPubKey | <code>Object</code> | Recipient's public keys (pub, epub) |
| senderKeyPair | <code>Object</code> | Sender's complete keypair (pub, epub, priv, epriv) |

**Example**
```js
// This is generally used internally by sendMessage
const recipientPubKey = await window.d3.getKeypair("0x1234...");
const secret = await window.d3.createSharedSecret(recipientPubKey, window.gunKeyPair);
const encrypted = await window.d3.encryptMessage("Secret message", secret);
```

<a name="encryptMessage"></a>

## encryptMessage(message, secret) ⇒ <code>Promise.&lt;string&gt;</code>
Encrypts a message using a shared secret.

**Returns**: <code>Promise.&lt;string&gt;</code> - Encrypted message.

| Param | Type | Description |
| --- | --- | --- |
| message | <code>string</code> | Message to encrypt |
| secret | <code>string</code> | Shared secret generated with createSharedSecret |

**Example**
```js
// See createSharedSecret example
```

<a name="getKeypair"></a>

## getKeypair(address) ⇒ <code>Promise.&lt;Object&gt;</code>
Retrieves the public part of a user's keypair.

**Returns**: <code>Promise.&lt;Object&gt;</code> - User's public keys.

| Property | Type | Description |
| --- | --- | --- |
| pub | <code>string</code> | User's public key |
| epub | <code>string</code> | User's public encryption key |

| Param | Type | Description |
| --- | --- | --- |
| address | <code>string</code> | User's Ethereum address |

**Example**
```js
const recipientAddress = "0x1234...";
const pubKeys = await window.d3.getKeypair(recipientAddress);
if (pubKeys && pubKeys.pub && pubKeys.epub) {
  console.log("User has valid public keys, can receive messages");
} else {
  console.log("User has not registered public keys");
}
```

<a name="registerKeypair"></a>

## registerKeypair(address, keypair) ⇒ <code>Promise.&lt;void&gt;</code>
Registers a user's public keys in the Gun database.

**Returns**: <code>Promise.&lt;void&gt;</code>

| Param | Type | Description |
| --- | --- | --- |
| address | <code>string</code> | User's Ethereum address |
| keypair | <code>Object</code> | Object containing public keys (pub, epub) |

**Example**
```js
// This is automatically used by connectWithMetaMask
// but can also be used manually
await window.d3.registerKeypair(address, {
  pub: gunKeyPair.pub,
  epub: gunKeyPair.epub
});
```

<a name="HashNamespace"></a>

## HashNamespace(string) ⇒ <code>string</code>
Encodes a string in base64, used to generate namespaces for conversations.

**Returns**: <code>string</code> - The base64 encoded string.

| Param | Type | Description |
| --- | --- | --- |
| string | <code>string</code> | String to encode |

**Example**
```js
// Generate a unique namespace for a conversation between two users
const userA = "0xabcd...".toLowerCase();
const userB = "0x1234...".toLowerCase();
const participants = [userA, userB].sort();
const namespace = window.d3.HashNamespace(participants.join(""));
```

<a name="createLogger"></a>

## createLogger() ⇒ <code>Object</code>
Creates a logger to track operations and errors.

**Returns**: <code>Object</code> - Logger object with methods for different log levels.

**Properties**:
- `debug` <code>Function</code>: Logs debug messages
- `info` <code>Function</code>: Logs informational messages
- `warn` <code>Function</code>: Logs warnings
- `error` <code>Function</code>: Logs errors
- `setLogLevel` <code>Function</code>: Sets the log level (debug, info, warn, error, none)
- `getLogLevel` <code>Function</code>: Gets the current log level

**Example**
```js
// Create a logger
const logger = createLogger();

// Set the log level
logger.setLogLevel("debug");

// Use the logger
logger.debug("Debug message");
logger.info("Informational message");
logger.warn("Warning");
logger.error("Critical error");

// Get the current log level
const currentLevel = logger.getLogLevel();
console.log(`Current log level: ${currentLevel}`);
```

<a name="dbConf"></a>

## dbConf ⇒ <code>Object</code>
Gun database configuration.

**Properties**:
- `peers` <code>Array.&lt;string&gt;</code>: Array of Gun peer URLs
- `localStorage` <code>boolean</code>: Whether to use localStorage for persistence
- `radisk` <code>boolean</code>: Whether to use radisk for persistence
- `axe` <code>boolean</code>: Whether to use axe for p2p communication
- `multicast` <code>boolean</code>: Whether to use multicast

**Example**
```js
// Access the configuration
console.log("Configured peers:", window.d3.dbConf.peers);

// Use the configuration to initialize a new Gun instance
const customGun = new Gun(window.d3.dbConf);
```
