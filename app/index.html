<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Shogun-D3 Chat - Demo</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            max-width: 800px;
            margin: 0 auto;
            background-color: white;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            padding: 20px;
        }
        h1 {
            text-align: center;
            color: #333;
        }
        .info {
            background-color: #e9f7fe;
            border: 1px solid #b3e5fc;
            border-radius: 5px;
            padding: 15px;
            margin-bottom: 20px;
            font-size: 14px;
        }
        .connect-section {
            margin-bottom: 20px;
            text-align: center;
        }
        button {
            background-color: #4CAF50;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            margin: 5px;
        }
        button:hover {
            background-color: #45a049;
        }
        button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }
        .wallet-info {
            margin: 10px 0;
            font-size: 14px;
        }
        .chat-section {
            display: none;
            margin-top: 20px;
        }
        .messages {
            border: 1px solid #ddd;
            border-radius: 5px;
            height: 300px;
            padding: 10px;
            overflow-y: auto;
            margin-bottom: 10px;
            background-color: #f9f9f9;
        }
        .message {
            padding: 8px 12px;
            margin-bottom: 8px;
            border-radius: 5px;
            max-width: 80%;
            word-wrap: break-word;
        }
        .message.sent {
            background-color: #e3f2fd;
            margin-left: auto;
            text-align: right;
        }
        .message.received {
            background-color: #f1f1f1;
        }
        .message .meta {
            font-size: 12px;
            color: #777;
            margin-top: 3px;
        }
        .input-area {
            display: flex;
            margin-top: 10px;
        }
        .input-area input {
            flex-grow: 1;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            margin-right: 10px;
        }
        .recipient-input {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            margin-bottom: 10px;
        }
        
        #chat-title {
            text-align: center;
            margin: 10px 0;
            color: #333;
            font-size: 16px;
            padding-bottom: 10px;
            border-bottom: 1px solid #eee;
        }
        
        .active {
            color: green;
            font-weight: bold;
        }
        
        .warning {
            color: orange;
            font-weight: bold;
        }
        
        .error {
            color: red;
            font-weight: bold;
        }
        
        .custom-button {
            background-color: #4C6FaF;
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 4px;
            cursor: pointer;
            margin-left: 10px;
            font-size: 13px;
        }
        
        .conversations-list {
            margin-top: 20px;
            border: 1px solid #ddd;
            border-radius: 5px;
            padding: 10px;
            max-height: 200px;
            overflow-y: auto;
            background-color: #f5f5f5;
        }
        
        .conversation-item {
            padding: 8px;
            border-bottom: 1px solid #eee;
            cursor: pointer;
        }
        
        .conversation-item:hover {
            background-color: #e9e9e9;
        }
        
        .conversation-item.active {
            background-color: #e3f2fd;
            font-weight: bold;
        }
        
        .conversation-item .address {
            font-size: 14px;
            color: #333;
        }
        
        .conversation-item .message-count {
            font-size: 12px;
            color: #777;
        }
        
        .chat-wrapper {
            display: flex;
            gap: 20px;
        }
        
        .chat-sidebar {
            width: 30%;
        }
        
        .chat-main {
            width: 70%;
        }
        
        .status-indicator {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 5px;
        }
        
        .status-indicator.online {
            background-color: #4CAF50;
        }
        
        .status-indicator.offline {
            background-color: #f44336;
        }
        
        .status-indicator.connecting {
            background-color: #ff9800;
            animation: pulse 1.5s infinite;
        }
        
        .connection-status {
            font-size: 12px;
            margin-top: 10px;
            padding: 5px;
            border-radius: 3px;
            background-color: #f5f5f5;
            display: inline-flex;
            align-items: center;
        }
        
        @keyframes pulse {
            0% { opacity: 0.5; }
            50% { opacity: 1; }
            100% { opacity: 0.5; }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Shogun-D3 Chat Demo</h1>
        
        <div class="info">
            <p>Questa è una demo di chat decentralizzata utilizzando la libreria Shogun-D3. Per utilizzarla hai bisogno di:</p>
            <ul>
                <li>Metamask installato nel browser</li>
                <li>Un indirizzo Ethereum</li>
            </ul>
        </div>
        
        <div id="wallet-section" class="connect-section">
            <button id="connectWallet">Connetti Wallet</button>
            <button id="refreshChat" style="background-color: #4682b4;">Ricarica Chat</button>
            <div id="walletInfo" class="wallet-info"></div>
            <div class="connection-status" id="gunStatus">
                <span class="status-indicator connecting"></span>
                <span>Connessione a Gun...</span>
            </div>
        </div>
        
        <div id="chatSection" class="chat-section">
            <div class="chat-wrapper">
                <div class="chat-sidebar">
                    <h3>Conversazioni</h3>
                    <div class="conversations-list" id="conversationsList">
                        <!-- Le conversazioni appariranno qui -->
                    </div>
                </div>
                <div class="chat-main">
                    <input type="text" class="recipient-input" id="recipientAddress" placeholder="Indirizzo ETH del destinatario (0x...)">
                    
                    <h3 id="chat-title">Seleziona un destinatario per iniziare a chattare</h3>
                    
                    <div class="messages" id="messagesContainer">
                        <!-- I messaggi appariranno qui -->
                    </div>
                    
                    <div class="input-area">
                        <input type="text" id="messageInput" placeholder="Scrivi un messaggio...">
                        <button id="sendMessage">Invia</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Librerie necessarie -->
    <script src="https://cdn.jsdelivr.net/npm/gun/gun.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/gun/sea.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/ethers@5.7.0/dist/ethers.umd.min.js"></script>
    <script src="shogun-core.js" ></script>
    <script src="d3.js"></script>
    <script>
        // Elementi DOM
        const connectWalletBtn = document.getElementById('connectWallet');
        const walletInfoEl = document.getElementById('walletInfo');
        const chatSection = document.getElementById('chatSection');
        const recipientAddressInput = document.getElementById('recipientAddress');
        const messagesContainer = document.getElementById('messagesContainer');
        const messageInput = document.getElementById('messageInput');
        const sendMessageBtn = document.getElementById('sendMessage');
        const keyPairStatusElement = document.createElement('div'); // Elemento per lo stato del keypair
        walletInfoEl.appendChild(keyPairStatusElement);

        // Variabili globali
        let userAddress = null;
        let provider = null;
        let wallet = null;
        let gunKeyPair = null;
        let activeConversations = new Set();
        let processedMessages = new Set(); // Per evitare messaggi duplicati
        let chatMessages = {}; // Nuovo oggetto per memorizzare i messaggi per ogni conversazione
        
        // Funzioni per persistenza dati in localStorage
        const saveMessagesToLocalStorage = () => {
            try {
                localStorage.setItem('shogun_d3_chat_messages', JSON.stringify(chatMessages));
                console.log('Messaggi salvati in localStorage');
            } catch (error) {
                console.error('Errore nel salvare i messaggi in localStorage:', error);
            }
        };
        
        const loadMessagesFromLocalStorage = () => {
            try {
                // Prova prima a caricare con il nuovo nome
                let saved = localStorage.getItem('shogun_d3_chat_messages');
                // Se non trova, prova con il vecchio nome per retrocompatibilità
                if (!saved) {
                    saved = localStorage.getItem('succus_chat_messages');
                }
                
                if (saved) {
                    chatMessages = JSON.parse(saved);
                    console.log('Messaggi caricati da localStorage:', Object.keys(chatMessages).length, 'conversazioni trovate');
                    return true;
                }
            } catch (error) {
                console.error('Errore nel caricare i messaggi da localStorage:', error);
            }
            return false;
        };
        
        // Carica i messaggi da localStorage all'avvio
        loadMessagesFromLocalStorage();
        
        // Funzione per controllare lo stato di Gun
        const checkGunStatus = async () => {
            try {
                const status = await window.d3.debug.testGunConnection();
                const statusElement = document.getElementById('gunStatus');
                
                if (status.success) {
                    statusElement.innerHTML = `
                        <span class="status-indicator online"></span>
                        <span>Gun connesso (latenza: ${status.latency}ms)</span>
                    `;
                    console.log("Gun connesso con latenza:", status.latency);
                    return true;
                } else {
                    statusElement.innerHTML = `
                        <span class="status-indicator offline"></span>
                        <span>Gun disconnesso: ${status.message}</span>
                    `;
                    console.error("Gun non connesso:", status.message);
                    return false;
                }
            } catch (error) {
                document.getElementById('gunStatus').innerHTML = `
                    <span class="status-indicator offline"></span>
                    <span>Errore Gun: ${error.message}</span>
                `;
                console.error("Errore nel controllo Gun:", error);
                return false;
            }
        };
        
        // Verifica lo stato di Gun ogni 10 secondi
        setInterval(checkGunStatus, 10000);
        
        // Verifica iniziale
        checkGunStatus();
        
        // Funzione per connettere il wallet
        const connectWallet = async () => {
            try {
                // Usa il metodo connectWithMetaMask di Shogun-D3 che gestisce tutto il flusso di autenticazione
                const result = await d3.connectWithMetaMask();
                
                if (!result || !result.address) {
                    console.error("Errore nella connessione: risultato non valido", result);
                    return;
                }
                
                userAddress = result.address;
                gunKeyPair = result.keypair;
                
                // Memorizza globalmente
                window.currentUserAddress = userAddress;
                window.gunKeyPair = gunKeyPair;
                
                console.log("Wallet connesso con successo:", userAddress);
                console.log("KeyPair ottenuto:", {
                    pub: gunKeyPair.pub ? "presente" : "mancante",
                    epub: gunKeyPair.epub ? "presente" : "mancante",
                    priv: gunKeyPair.priv ? "presente" : "mancante", 
                    epriv: gunKeyPair.epriv ? "presente" : "mancante"
                });
                
                // Aggiorna UI
                walletInfoEl.innerHTML = `
                    <p>Wallet connesso!</p>
                    <p>Indirizzo: <code>${userAddress}</code></p>
                `;
                
                keyPairStatusElement.innerHTML = `<span class="active">✓ Keypair attivo</span>`;
                
                // Abilita chat
                chatSection.style.display = 'block';
            } catch (error) {
                console.error("Errore durante la connessione al wallet:", error);
                alert("Errore durante la connessione al wallet. Controlla la console per i dettagli.");
            }
        };
        
        // Funzione per aggiornare la lista delle conversazioni
        const updateConversationsList = () => {
            const conversationsList = document.getElementById('conversationsList');
            conversationsList.innerHTML = '';
            
            const currentRecipient = recipientAddressInput.value.trim();
            
            // Ottieni tutte le conversazioni
            const conversations = Object.keys(chatMessages);
            
            if (conversations.length === 0) {
                const emptyItem = document.createElement('div');
                emptyItem.className = 'conversation-item';
                emptyItem.innerHTML = '<div class="address">Nessuna conversazione</div>';
                conversationsList.appendChild(emptyItem);
                return;
            }
            
            // Ordina per data dell'ultimo messaggio (più recente prima)
            conversations.sort((a, b) => {
                const lastMsgA = chatMessages[a].length > 0 ? 
                    chatMessages[a][chatMessages[a].length - 1].timestamp : 0;
                const lastMsgB = chatMessages[b].length > 0 ? 
                    chatMessages[b][chatMessages[b].length - 1].timestamp : 0;
                return lastMsgB - lastMsgA;
            });
            
            // Crea un elemento per ogni conversazione
            conversations.forEach(address => {
                const item = document.createElement('div');
                item.className = 'conversation-item';
                if (address === currentRecipient) {
                    item.className += ' active';
                }
                
                const messageCount = chatMessages[address].length;
                const lastMessage = messageCount > 0 ? 
                    chatMessages[address][chatMessages[address].length - 1].decrypted : '';
                const lastMessagePreview = lastMessage.length > 20 ? 
                    lastMessage.substring(0, 20) + '...' : lastMessage;
                
                item.innerHTML = `
                    <div class="address">${address.slice(0, 6)}...${address.slice(-4)}</div>
                    <div class="message-count">${messageCount} messaggi</div>
                    <div class="last-message">${lastMessagePreview}</div>
                `;
                
                item.addEventListener('click', () => {
                    recipientAddressInput.value = address;
                    startListeningToConversation(address);
                    
                    // Aggiorna lo stato attivo
                    document.querySelectorAll('.conversation-item').forEach(el => {
                        el.classList.remove('active');
                    });
                    item.classList.add('active');
                });
                
                conversationsList.appendChild(item);
            });
        };
        
        // Funzione per inviare un messaggio utilizzando direttamente d3.sendmessage
        const sendMessage = async () => {
            const message = messageInput.value.trim();
            const recipientAddress = recipientAddressInput.value.trim();
            
            if (!message || !recipientAddress) {
                alert("Per favore inserisci sia un messaggio che un indirizzo destinatario.");
                return;
            }
            
            try {
                // Aggiungi un messaggio di attesa
                const loadingMsg = document.createElement('div');
                loadingMsg.classList.add('message', 'sent');
                loadingMsg.innerHTML = `Invio in corso...`;
                messagesContainer.appendChild(loadingMsg);
                messagesContainer.scrollTop = messagesContainer.scrollHeight;
                
                // Verifica che il destinatario abbia registrato una chiave pubblica
                console.log(`Verifica keypair per destinatario ${recipientAddress}`);
                const recipientPubKey = await d3.getKeypair(recipientAddress);
                
                if (!recipientPubKey || !recipientPubKey.pub || !recipientPubKey.epub) {
                    // Rimuovi il messaggio di caricamento
                    messagesContainer.removeChild(loadingMsg);
                    
                    console.error(`Keypair non valido per il destinatario ${recipientAddress}:`, recipientPubKey);
                    
                    // Prova ad auto-generare una chiave pubblica per test (solo in ambiente demo)
                    if (confirm(`Il destinatario ${recipientAddress} non ha un keypair valido. Vuoi generare una chiave pubblica per questo utente (solo per test)?`)) {
                        const tempKeyPair = await d3.SEA.pair();
                        const publicPart = {
                            pub: tempKeyPair.pub,
                            epub: tempKeyPair.epub
                        };
                        
                        // Registra la parte pubblica in Gun
                        await d3.registerKeypair(recipientAddress, publicPart);
                        
                        console.log(`Keypair pubblico generato e salvato per ${recipientAddress}:`, publicPart);
                        alert(`Keypair pubblico generato per ${recipientAddress}. Riprova a inviare il messaggio.`);
                        return;
                    }
                    
                    alert(`Il destinatario ${recipientAddress} non ha un keypair valido. Non può ricevere messaggi.`);
                    return;
                }
                
                console.log(`Keypair valido trovato per ${recipientAddress}, procedo con l'invio`);
                console.log(`Chiavi pubbliche del destinatario:`, {
                    pub: recipientPubKey.pub ? recipientPubKey.pub.substring(0, 15) + "..." : "mancante",
                    epub: recipientPubKey.epub ? recipientPubKey.epub.substring(0, 15) + "..." : "mancante"
                });
                
                // Invia il messaggio usando la libreria Shogun-D3
                const result = await d3.sendmessage(message, [recipientAddress], gunKeyPair);
                
                // Rimuovi il messaggio di caricamento
                messagesContainer.removeChild(loadingMsg);
                
                if (result.sent) {
                    console.log(`Messaggio inviato con successo a ${recipientAddress}:`, message);
                    console.log("Dettagli risultato:", result);
                    
                    // Pulisci l'input del messaggio
                    messageInput.value = '';
                    
                    // Genera un ID univoco per il messaggio
                    const uniqueId = `sent_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`;
                    
                    // Aggiungi il messaggio all'interfaccia
                    const messageTime = new Date();
                    const timeString = messageTime.toLocaleTimeString() + ' ' + messageTime.toLocaleDateString();
                    
                    const messageElement = document.createElement('div');
                    messageElement.className = 'message sent';
                    messageElement.setAttribute('data-msg-id', uniqueId);
                    messageElement.innerHTML = `
                        ${message}
                        <div class="meta">
                            ${timeString}
                            <span class="message-sender">Tu</span>
                        </div>
                    `;
                    
                    messagesContainer.appendChild(messageElement);
                    messagesContainer.scrollTop = messagesContainer.scrollHeight;
                    
                    // Inizializza l'array dei messaggi per questa conversazione se non esiste già
                    if (!chatMessages[recipientAddress]) {
                        chatMessages[recipientAddress] = [];
                    }
                    
                    // Salva il messaggio nell'array dei messaggi di questa conversazione
                    const messageToSave = {
                        decrypted: message,
                        isSentByMe: true,
                        timestamp: messageTime.getTime(),
                        sender: userAddress,
                        messageKey: uniqueId
                    };
                    chatMessages[recipientAddress].push(messageToSave);
                    console.log(`Messaggio inviato salvato in memoria per la conversazione con ${recipientAddress}`);
                    
                    // Salva i messaggi aggiornati in localStorage
                    saveMessagesToLocalStorage();
                    
                    // Aggiorna la lista delle conversazioni
                    updateConversationsList();
                    
                    // Inizia ad ascoltare i messaggi se non lo stai già facendo
                    startListeningToConversation(recipientAddress);
                } else {
                    console.error(`Errore nell'invio del messaggio:`, result.why);
                    alert("Errore durante l'invio del messaggio: " + (result.why ? result.why.message || result.why : "Errore sconosciuto"));
                }
                
            } catch (error) {
                console.error("Errore durante l'invio del messaggio:", error);
                alert("Errore durante l'invio del messaggio: " + error.message);
            }
        };
        
        // Funzione per iniziare ad ascoltare una conversazione
        const startListeningToConversation = async (recipientAddress) => {
            if (!recipientAddress || !userAddress) {
                console.warn("Impossibile iniziare ad ascoltare: indirizzo del destinatario o mittente mancante");
                return;
            }
            
            // Verifica l'input
            const recipientAddr = recipientAddress.trim();
            if (!recipientAddr.startsWith('0x')) {
                console.warn("Indirizzo destinatario non valido:", recipientAddr);
                alert("Inserisci un indirizzo Ethereum valido che inizi con 0x");
                return;
            }
            
            console.log(`Inizio ascolto conversazione con ${recipientAddr}`);
            
            // Interrompi ogni precedente ascolto per evitare callback multipli
            window.d3.stopReceiveMessage && window.d3.stopReceiveMessage(recipientAddr);
            
            // Eseguiamo un'analisi iniziale del namespace
            const normalizedRecipient = userAddress.toLowerCase();
            const normalizedSender = recipientAddr.toLowerCase();
            const participants = [normalizedSender, normalizedRecipient].sort();
            const sortedParticipants = participants.join("");
            const chatNamespace = window.d3.HashNamespace(sortedParticipants);
            
            console.log(`Ascolto namespace: ${chatNamespace}`);
            
            // Inizializza l'array dei messaggi per questa conversazione se non esiste già
            if (!chatMessages[recipientAddr]) {
                chatMessages[recipientAddr] = [];
            }
            
            // Pulisci l'interfaccia
            messagesContainer.innerHTML = '';
            
            // Tracciamo tutti i messaggi già conosciuti per evitare duplicati
            const knownMessageIds = new Set();
            
            // Carica i messaggi salvati per questa conversazione
            console.log(`Carico ${chatMessages[recipientAddr].length} messaggi salvati per la conversazione con ${recipientAddr}`);
            chatMessages[recipientAddr].forEach(messageData => {
                const { decrypted, isSentByMe, timestamp, sender, messageKey } = messageData;
                
                // Aggiungi l'ID al set di messaggi conosciuti
                if (messageKey) {
                    knownMessageIds.add(messageKey);
                }
                
                // Formatta e visualizza il messaggio
                const messageTime = new Date(timestamp);
                const timeString = messageTime.toLocaleTimeString() + ' ' + messageTime.toLocaleDateString();
                
                const messageElement = document.createElement('div');
                messageElement.className = isSentByMe ? 'message sent' : 'message received';
                messageElement.setAttribute('data-msg-id', messageKey);
                messageElement.innerHTML = `
                    ${decrypted}
                    <div class="meta">
                        ${timeString}
                        <span class="message-sender">${isSentByMe ? 'Tu' : sender.slice(0, 6) + '...'}</span>
                    </div>
                `;
                
                messagesContainer.appendChild(messageElement);
            });
            
            // Scorrimento automatico verso il basso dopo aver caricato i messaggi
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
            
            // Imposta il titolo della chat
            document.getElementById('chat-title').textContent = `Chat con ${recipientAddr.slice(0, 6)}...${recipientAddr.slice(-4)}`;
            
            // Utilizziamo un set per tracciare i messaggi già visualizzati
            const displayedMessages = new Set(knownMessageIds);
            
            // Utilizziamo la nuova versione di receiveMessage
            window.d3.receiveMessage(recipientAddr, (messageData) => {
                // Ignora log verbosi
                // console.log("Messaggio ricevuto dal callback:", messageData);
                
                const { decrypted, isSentByMe, timestamp, sender, messageKey, originalData } = messageData;
                
                if (!decrypted) {
                    console.warn("Messaggio non decifrabile:", messageData);
                    return;
                }
                
                // Creiamo un ID univoco per il messaggio
                const uniqueId = messageKey || `msg_${timestamp}_${Math.random().toString(36).substring(2, 9)}`;
                
                // Verifica se il messaggio è già stato visualizzato o è un messaggio inviato da noi
                // I messaggi inviati da noi vengono già visualizzati dalla funzione sendMessage
                if (displayedMessages.has(uniqueId) || (isSentByMe && sender === userAddress)) {
                    console.log(`Messaggio ${uniqueId} già visualizzato o inviato da noi, ignorato`);
                    return;
                }
                
                // Verifica se il messaggio è già presente nel DOM
                const existingMsg = document.querySelector(`.message[data-msg-id="${uniqueId}"]`);
                if (existingMsg) {
                    console.log(`Messaggio ${uniqueId} già nel DOM, ignorato`);
                    displayedMessages.add(uniqueId);
                    return;
                }
                
                console.log(`Visualizzazione nuovo messaggio ricevuto: ${decrypted.substring(0, 30)}...`);
                
                // Salva il messaggio nell'array dei messaggi di questa conversazione
                const messageToSave = { decrypted, isSentByMe, timestamp, sender, messageKey: uniqueId };
                chatMessages[recipientAddr].push(messageToSave);
                
                // Salva i messaggi aggiornati in localStorage
                saveMessagesToLocalStorage();
                
                // Aggiorna la lista delle conversazioni
                updateConversationsList();
                
                // Formatta e visualizza il messaggio
                const messageTime = new Date(timestamp);
                const timeString = messageTime.toLocaleTimeString() + ' ' + messageTime.toLocaleDateString();
                
                const messageElement = document.createElement('div');
                messageElement.className = isSentByMe ? 'message sent' : 'message received';
                messageElement.setAttribute('data-msg-id', uniqueId);
                messageElement.innerHTML = `
                    ${decrypted}
                    <div class="meta">
                        ${timeString}
                        <span class="message-sender">${isSentByMe ? 'Tu' : sender.slice(0, 6) + '...'}</span>
                    </div>
                `;
                
                messagesContainer.appendChild(messageElement);
                displayedMessages.add(uniqueId);
                
                // Scorrimento automatico verso il basso
                messagesContainer.scrollTop = messagesContainer.scrollHeight;
            });
        };
        
        // Funzione per visualizzare un messaggio nell'interfaccia
        const displayMessage = (message, isSent, timestamp, msgId = null) => {
            // Genera un id per il messaggio se non è fornito
            const messageId = msgId || `${message}-${timestamp.getTime()}-${isSent ? 'sent' : 'received'}`;
            
            // Controlla che il messaggio non sia già visualizzato
            if (document.querySelector(`.message[data-id="${messageId}"]`) || 
                (msgId && document.querySelector(`.message[data-msg-id="${msgId}"]`))) {
                return; // Il messaggio è già visualizzato
            }
            
            const messageEl = document.createElement('div');
            messageEl.classList.add('message');
            messageEl.classList.add(isSent ? 'sent' : 'received');
            messageEl.setAttribute('data-id', messageId);
            if (msgId) {
                messageEl.setAttribute('data-msg-id', msgId);
            }
            
            messageEl.innerHTML = `
                ${message}
                <div class="meta">${formatDate(timestamp)}</div>
            `;
            
            messagesContainer.appendChild(messageEl);
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
        };
        
        // Funzione per formattare la data
        const formatDate = (date) => {
            return date.toLocaleTimeString() + ' ' + date.toLocaleDateString();
        };
        
        // Event listeners
        connectWalletBtn.addEventListener('click', connectWallet);
        sendMessageBtn.addEventListener('click', sendMessage);
        
        // Quando un destinatario viene inserito, inizia ad ascoltare i messaggi
        recipientAddressInput.addEventListener('input', (e) => {
            const recipientAddress = e.target.value.trim();
            
            // Verifica che sia un indirizzo valido (comincia con 0x e ha la lunghezza giusta)
            if (recipientAddress.startsWith('0x') && recipientAddress.length > 10) {
                // Se l'utente è cambiato, inizia l'ascolto
                startListeningToConversation(recipientAddress);
            }
        });
        
        // Refresh chat button
        document.getElementById('refreshChat').addEventListener('click', async () => {
            const recipientAddr = recipientAddressInput.value.trim();
            if (!recipientAddr || !recipientAddr.startsWith('0x')) {
                alert("Inserisci prima un indirizzo destinatario valido");
                return;
            }
            
            // Pulisci i messaggi visualizzati
            messagesContainer.innerHTML = '';
            
            // Aggiungiamo un messaggio di caricamento
            const loadingMessage = document.createElement('div');
            loadingMessage.className = 'message';
            loadingMessage.style.textAlign = 'center';
            loadingMessage.style.color = '#888';
            loadingMessage.innerText = 'Caricamento messaggi in corso...';
            messagesContainer.appendChild(loadingMessage);
            
            // Usa la nuova funzione per leggere e mostrare direttamente i messaggi
            try {
                await exploreAndDisplayChatMessages(recipientAddr);
                console.log("Chat ricaricata per", recipientAddr);
                
                // Rimuoviamo il messaggio di caricamento
                messagesContainer.removeChild(loadingMessage);
            } catch (error) {
                console.error("Errore nella ricarica chat:", error);
                
                // Cambiamo il messaggio di caricamento in messaggio di errore
                loadingMessage.style.color = 'red';
                loadingMessage.innerText = `Errore nel caricamento: ${error.message}`;
            }
        });
        
        // Funzione che recupera e mostra i messaggi direttamente da Gun
        async function exploreAndDisplayChatMessages(recipientAddr) {
            console.log("Recupero diretto messaggi per chat con:", recipientAddr);
            
            if (!userAddress || !window.gunKeyPair) {
                console.error("Keypair o indirizzo utente non disponibili");
                return;
            }
            
            // Genera il namespace della chat
            const normalizedRecipient = userAddress.toLowerCase();
            const normalizedSender = recipientAddr.toLowerCase();
            const participants = [normalizedSender, normalizedRecipient].sort();
            const sortedParticipants = participants.join("");
            const chatNamespace = window.d3.HashNamespace(sortedParticipants);
            
            console.log("Namespace della chat:", chatNamespace);
            console.log("Participants array:", participants);
            console.log("Sorted participants string:", sortedParticipants);
            
            // Verifica diretta del namespace
            window.gun.get(chatNamespace).once((data) => {
                if (!data) {
                    console.warn(`Namespace ${chatNamespace} non trovato o vuoto`);
                } else {
                    console.log(`Namespace ${chatNamespace} trovato:`, data);
                    
                    // Conta manualmente i messaggi
                    let count = 0;
                    for (let key in data) {
                        if (key !== '_' && key !== '#') {
                            count++;
                            console.log(`- Chiave ${key} trovata`);
                        }
                    }
                    console.log(`Trovate ${count} chiavi nel namespace`);
                }
            });
            
            // Crea lo shared secret per decifrare i messaggi
            const sharedSecret = await window.d3.createSharedSecret(recipientAddr, window.gunKeyPair);
            console.log("Shared secret creato per lettura diretta");
            
            // Inizializza l'array dei messaggi per questa conversazione se non esiste già
            if (!chatMessages[recipientAddr]) {
                chatMessages[recipientAddr] = [];
            }
            
            // Ottieni tutti i messaggi da questo namespace
            return new Promise((resolve) => {
                console.log("Lettura diretta di tutti i messaggi in:", chatNamespace);
                
                // Pulizia messaggi visualizzati
                messagesContainer.innerHTML = '';
                
                let messageCount = 0;
                let displayedCount = 0;
                
                window.gun.get(chatNamespace).map().once(async (data, key) => {
                    try {
                        // Ignora la chiave speciale "_" di Gun
                        if (key === '_' || !data || !data.encryptedMSG) {
                            return;
                        }
                        
                        messageCount++;
                        console.log(`Trovato messaggio [${key}]:`, {
                            from: data.from && data.from.substring(0, 10) + "...",
                            to: data.to && data.to.substring(0, 10) + "...",
                            date: new Date(data.date).toLocaleString()
                        });
                        
                        try {
                            // Decodifica direttamente il messaggio
                            const decrypted = await window.d3.decryptMessage(data, window.gunKeyPair);
                            
                            // Prepara i dati per la visualizzazione
                            const timestamp = data.date || Date.now();
                            const messageTime = new Date(timestamp);
                            const timeString = messageTime.toLocaleTimeString() + ' ' + messageTime.toLocaleDateString();
                            
                            // Determina se il messaggio è stato inviato da noi
                            const isSentByMe = (data.from && data.from.toLowerCase() === normalizedRecipient);
                            
                            // Crea un ID univoco per il messaggio per evitare duplicati
                            const uniqueId = `${key}_${timestamp}`;
                            
                            // Verifica se questo messaggio è già stato salvato in memoria
                            const existingMessageIndex = chatMessages[recipientAddr].findIndex(m => m.messageKey === uniqueId);
                            
                            if (existingMessageIndex === -1) {
                                // Se non esiste già, salva il messaggio nell'array dei messaggi di questa conversazione
                                const messageToSave = {
                                    decrypted,
                                    isSentByMe,
                                    timestamp,
                                    sender: isSentByMe ? userAddress : data.from,
                                    messageKey: uniqueId
                                };
                                chatMessages[recipientAddr].push(messageToSave);
                            }
                            
                            // Verifica se questo messaggio è già visualizzato
                            if (document.querySelector(`.message[data-msg-id="${uniqueId}"]`)) {
                                console.log(`Messaggio ${uniqueId} già visualizzato`);
                                return;
                            }
                            
                            console.log(`Visualizzazione diretta messaggio: ${decrypted}`);
                            
                            // Crea elemento messaggio
                            const messageElement = document.createElement('div');
                            messageElement.className = isSentByMe ? 'message sent' : 'message received';
                            messageElement.setAttribute('data-msg-id', uniqueId);
                            messageElement.innerHTML = `
                                ${decrypted}
                                <div class="meta">
                                    ${timeString}
                                    <span class="message-sender">${isSentByMe ? 'Tu' : data.from.slice(0, 6) + '...'}</span>
                                </div>
                            `;
                            
                            messagesContainer.appendChild(messageElement);
                            displayedCount++;
                            
                            // Scorrimento automatico verso il basso
                            messagesContainer.scrollTop = messagesContainer.scrollHeight;
                        } catch (decodingError) {
                            console.error("Errore decodifica messaggio:", decodingError);
                        }
                    } catch (error) {
                        console.error("Errore nel processare messaggio:", error);
                    }
                });
                
                // Completa l'operazione dopo un breve timeout
                setTimeout(() => {
                    console.log(`Recupero completato: trovati ${messageCount} messaggi, visualizzati ${displayedCount}`);
                    
                    // Ordina i messaggi cronologicamente
                    chatMessages[recipientAddr].sort((a, b) => a.timestamp - b.timestamp);
                    
                    // Salva i messaggi aggiornati in localStorage
                    saveMessagesToLocalStorage();
                    
                    // Aggiorna la lista delle conversazioni
                    updateConversationsList();
                    
                    // Se non ci sono messaggi trovati, proviamo un ascolto alternativo
                    if (messageCount === 0) {
                        console.log("Nessun messaggio trovato, provo con ascolto diretto di gun map");
                        
                        window.gun.get(chatNamespace).map().on(async (data, key) => {
                            console.log(`Ascolto alternativo - evento per chiave ${key}:`, data);
                            if (key === '_' || !data || !data.encryptedMSG) return;
                            
                            try {
                                // Tenta di decifrare il messaggio con diverse strategie
                                const decrypted = await window.d3.decryptMessage(data, window.gunKeyPair);
                                console.log(`Messaggio decifrato con ascolto alternativo: ${decrypted}`);
                                
                                // Processa il messaggio qui...
                                console.log("Messaggio rilevato con ascolto alternativo:", {
                                    decrypted,
                                    from: data.from,
                                    to: data.to,
                                    date: new Date(data.date).toLocaleString()
                                });
                            } catch (e) {
                                console.error("Errore nella decifratura alternativa:", e);
                            }
                        });
                        
                        const emptyMessage = document.createElement('div');
                        emptyMessage.className = 'message';
                        emptyMessage.style.textAlign = 'center';
                        emptyMessage.style.color = '#888';
                        emptyMessage.innerText = 'Nessun messaggio trovato. Inizia una conversazione!';
                        messagesContainer.appendChild(emptyMessage);
                    }
                    
                    resolve({messageCount, displayedCount});
                }, 3000);
            });
        }
        
        // Funzione per forzare l'aggiornamento dei messaggi
        const forceMessageUpdate = async (recipientAddr) => {
            if (!recipientAddr || !userAddress || !gunKeyPair) {
                console.error("Impossibile aggiornare i messaggi: dati mancanti");
                return;
            }
            
            console.log("Forzo aggiornamento messaggi per", recipientAddr);
            
            try {
                // Pulisci i messaggi visualizzati
                messagesContainer.innerHTML = '';
                
                // Prova prima l'approccio diretto di lettura
                await exploreAndDisplayChatMessages(recipientAddr);
                
                // Se necessario, riavvia anche l'ascolto normale
                console.log("Riavvio ascolto normale dopo lettura diretta");
                startListeningToConversation(recipientAddr);
            } catch (error) {
                console.error("Errore durante l'aggiornamento forzato:", error);
                // Fallback al metodo normale
                startListeningToConversation(recipientAddr);
            }
        };
        
        // Evento per l'invio del messaggio con il tasto Enter
        messageInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                sendMessage();
            }
        });
        
        // Aggiungiamo un gestore per salvare i messaggi quando l'utente lascia la pagina
        window.addEventListener('beforeunload', () => {
            saveMessagesToLocalStorage();
        });
        
        // Aggiorna la lista delle conversazioni all'avvio
        window.addEventListener('DOMContentLoaded', () => {
            if (Object.keys(chatMessages).length > 0) {
                updateConversationsList();
            }
        });
    </script>
</body>
</html> 