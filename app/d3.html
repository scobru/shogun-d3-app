<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Shogun-D3 Chat</title>
    <style>
        :root {
            /* Light theme */
            --primary-color-light: #2D3436;
            --secondary-color-light: #636E72;
            --accent-color-light: #00B894;
            --bg-color-light: #FFFFFF;
            --light-gray-light: #F1F2F6;
            --message-bg-light: #F8F9FA;
            --shadow-light: rgba(0, 0, 0, 0.05);

            /* Dark theme */
            --primary-color-dark: #FFFFFF;
            --secondary-color-dark: #CBD5E0;
            --accent-color-dark: #00D1A1;
            --bg-color-dark: #1A202C;
            --light-gray-dark: #2D3748;
            --message-bg-dark: #2D3748;
            --shadow-dark: rgba(0, 0, 0, 0.3);

            /* Common variables */
            --border-radius: 12px;
            --spacing: 12px;
            --transition: all 0.2s ease;

            /* Default theme (light) */
            --primary-color: var(--primary-color-light);
            --secondary-color: var(--secondary-color-light);
            --accent-color: var(--accent-color-light);
            --bg-color: var(--bg-color-light);
            --light-gray: var(--light-gray-light);
            --message-bg: var(--message-bg-light);
            --shadow: var(--shadow-light);
        }

        [data-theme="dark"] {
            --primary-color: var(--primary-color-dark);
            --secondary-color: var(--secondary-color-dark);
            --accent-color: var(--accent-color-dark);
            --bg-color: var(--bg-color-dark);
            --light-gray: var(--light-gray-dark);
            --message-bg: var(--message-bg-dark);
            --shadow: var(--shadow-dark);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #f3e8ff, #ddd6fe, #c7d2fe);
            color: var(--primary-color);
            line-height: 1.6;
            transition: var(--transition);
            min-height: 100vh;
        }

        [data-theme="dark"] body {
            background: linear-gradient(135deg, #1a1a2e, #16213e, #0f3460);
        }

        .container {
            max-width: 100%;
            margin: 0;
            height: 100vh;
            padding: 0;
            background: transparent;
        }

        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0;
            padding: 16px 24px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.3);
            position: relative;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 0;
        }

        [data-theme="dark"] .header {
            background: rgba(26, 32, 44, 0.8);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .header .flex {
            display: flex;
        }

        /* Logging control panel */
        .logging-controls {
            position: fixed;
            top: 10px;
            right: 10px;
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(10px);
            border-radius: 8px;
            padding: 10px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            z-index: 1000;
            font-size: 12px;
        }

        [data-theme="dark"] .logging-controls {
            background: rgba(26, 32, 44, 0.9);
            color: var(--primary-color-dark);
        }

        .logging-controls select {
            background: var(--bg-color);
            color: var(--primary-color);
            border: 1px solid var(--secondary-color);
            border-radius: 4px;
            padding: 4px 8px;
            font-size: 11px;
            margin-left: 8px;
        }

        .logging-controls label {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 5px;
        }

        .header .items-center {
            align-items: center;
        }

        .header .space-x-3>*+* {
            margin-left: 12px;
        }

        .header h1 {
            background: linear-gradient(135deg, #8B5CF6, #3B82F6);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            font-size: 1.5rem;
            font-weight: bold;
            margin: 0;
        }

        .header p {
            margin: 0;
            font-size: 0.875rem;
            color: var(--secondary-color);
        }

        .theme-toggle {
            background: var(--light-gray);
            border: none;
            color: var(--primary-color);
            cursor: pointer;
            padding: 10px;
            width: 60px;
            height: 40px;
            border-radius: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
            transition: var(--transition);
            box-shadow: 0 2px 4px var(--shadow);
        }

        .theme-toggle:hover {
            background-color: var(--accent-color);
            color: white;
            transform: translateY(-2px);
        }

        .info {
            background: rgba(255, 255, 255, 0.8);
            backdrop-filter: blur(10px);
            padding: var(--spacing);
            border-radius: 16px;
            margin-bottom: var(--spacing);
            font-size: 0.95rem;
            border: 1px solid rgba(255, 255, 255, 0.3);
            box-shadow: 0 8px 32px rgba(139, 92, 246, 0.1);
        }

        .connect-section {
            text-align: center;
            margin-bottom: 0;
            padding: 16px;
            background: rgba(255, 255, 255, 0.8);
            backdrop-filter: blur(10px);
            border-radius: 0;
            box-shadow: 0 2px 8px rgba(139, 92, 246, 0.05);
            border-bottom: 1px solid rgba(255, 255, 255, 0.3);
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 8px;
            min-height: 60px;
            align-items: center;
        }

        [data-theme="dark"] .connect-section {
            background: rgba(26, 32, 44, 0.8);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        }

        .connect-section .flex {
            display: flex;
        }

        .connect-section .flex-col {
            flex-direction: column;
        }

        .connect-section .items-center {
            align-items: center;
        }

        .connect-section .justify-center {
            justify-content: center;
        }

        .connect-section .space-y-4>*+* {
            margin-top: 12px;
        }

        .connect-section .space-x-2>*+* {
            margin-left: 6px;
        }

        .connect-section .gap-3 {
            gap: 8px;
        }

        .connect-section .flex-wrap {
            flex-wrap: wrap;
        }

        /* Stili per i pulsanti discreti come Signal */
        .connect-section button {
            background: rgba(139, 92, 246, 0.1);
            border: 1px solid rgba(139, 92, 246, 0.2);
            color: #8B5CF6;
            padding: 8px 16px;
            border-radius: 20px;
            font-weight: 500;
            font-size: 0.85rem;
            cursor: pointer;
            transition: all 0.2s ease;
            transform: scale(1);
            box-shadow: none;
            opacity: 0.8;
        }

        .connect-section button:hover {
            transform: scale(1.02);
            background: rgba(139, 92, 246, 0.15);
            border-color: rgba(139, 92, 246, 0.3);
            opacity: 1;
        }

        .connect-section button:nth-child(2) {
            background: rgba(107, 114, 128, 0.1);
            border-color: rgba(107, 114, 128, 0.2);
            color: #6B7280;
        }

        .connect-section button:nth-child(2):hover {
            background: rgba(107, 114, 128, 0.15);
            border-color: rgba(107, 114, 128, 0.3);
        }

        .connect-section button:nth-child(3) {
            background: rgba(34, 197, 94, 0.1);
            border-color: rgba(34, 197, 94, 0.2);
            color: #22C55E;
        }

        .connect-section button:nth-child(3):hover {
            background: rgba(34, 197, 94, 0.15);
            border-color: rgba(34, 197, 94, 0.3);
        }

        .connect-section button:nth-child(4) {
            background: rgba(249, 115, 22, 0.1);
            border-color: rgba(249, 115, 22, 0.2);
            color: #F97316;
        }

        .connect-section button:nth-child(4):hover {
            background: rgba(249, 115, 22, 0.15);
            border-color: rgba(249, 115, 22, 0.3);
        }

        /* Nascondi i bottoni quando connesso */
        .connect-section.connected {
            min-height: 40px;
            padding: 8px 16px;
        }

        .connect-section.connected .button-group {
            display: none;
        }

        .connect-section.connected .status-group {
            display: flex;
            align-items: center;
            gap: 16px;
            width: 100%;
            justify-content: center;
        }

        .connect-section .button-group {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .connect-section .status-group {
            display: none;
        }

        /* ‚úÖ NUOVO: Mantieni i pulsanti di debug sempre visibili */
        .connect-section.connected .debug-buttons {
            display: flex !important;
            gap: 8px;
            flex-wrap: wrap;
            justify-content: center;
            margin-top: 8px;
        }

        .connect-section.connected .debug-buttons button {
            font-size: 0.75rem;
            padding: 6px 12px;
            min-width: auto;
        }

        button {
            background-color: var(--accent-color);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: var(--border-radius);
            cursor: pointer;
            font-size: 0.95rem;
            font-weight: 500;
            transition: var(--transition);
            min-width: 150px;
            box-shadow: 0 2px 4px var(--shadow);
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px var(--shadow);
        }

        button:active {
            transform: translateY(0);
        }

        button:disabled {
            background-color: var(--secondary-color);
            cursor: not-allowed;
            opacity: 0.7;
        }

        .chat-section {
            display: none;
            height: calc(100vh - 200px);
        }

        .chat-wrapper {
            display: grid;
            grid-template-columns: 280px 1fr;
            gap: 0;
            height: 100%;
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(10px);
            padding: 0;
            border-radius: 0;
            margin-top: 0;
            border: none;
            box-shadow: none;
        }

        [data-theme="dark"] .chat-wrapper {
            background: rgba(26, 32, 44, 0.9);
        }

        .conversations-list {
            background: rgba(255, 255, 255, 0.8);
            backdrop-filter: blur(10px);
            border-radius: 0;
            overflow-y: auto;
            padding: 16px;
            height: 100%;
            border-right: 1px solid rgba(255, 255, 255, 0.3);
            display: flex;
            flex-direction: column;
        }

        .conversations-header {
            padding-bottom: 16px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.3);
            margin-bottom: 16px;
        }

        .conversations-header h3 {
            margin: 0 0 12px 0;
            font-size: 1.1rem;
            font-weight: 600;
            color: var(--primary-color);
        }

        .new-conversation-btn {
            width: 100%;
            padding: 8px 12px;
            background: linear-gradient(135deg, #8B5CF6, #3B82F6);
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 0.9rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .new-conversation-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(139, 92, 246, 0.3);
        }

        .conversations-content {
            flex: 1;
            overflow-y: auto;
        }

        .conversation-item {
            padding: 10px;
            border-radius: var(--border-radius);
            cursor: pointer;
            transition: var(--transition);
            margin-bottom: 6px;
            background-color: var(--bg-color);
            border: 1px solid var(--light-gray);
        }

        .conversation-item:hover {
            transform: translateX(2px);
            border-color: var(--accent-color);
        }

        .conversation-item.active {
            background-color: var(--accent-color);
            color: white;
            transform: translateX(2px);
            border-color: transparent;
        }

        .conversation-item .address {
            font-weight: 600;
            margin-bottom: 4px;
            color: var(--primary-color);
        }

        .conversation-item .message-count {
            font-size: 0.8rem;
            opacity: 0.8;
            color: var(--secondary-color);
        }

        .conversation-item .last-message {
            font-size: 0.9rem;
            opacity: 0.9;
            margin-top: 4px;
            color: var(--secondary-color);
        }

        .messages {
            height: 100%;
            display: flex;
            flex-direction: column;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 0;
            overflow: hidden;
            border: none;
            box-shadow: none;
        }

        [data-theme="dark"] .messages {
            background: rgba(26, 32, 44, 0.95);
        }

        .messages-header {
            padding: 16px;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-bottom: 1px solid rgba(255, 255, 255, 0.3);
            position: sticky;
            top: 0;
            z-index: 1;
            display: flex;
            align-items: center;
            gap: 12px;
        }

        [data-theme="dark"] .messages-header {
            background: rgba(26, 32, 44, 0.95);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .messages-header .window-controls {
            display: flex;
            gap: 6px;
            margin-right: 12px;
        }

        .messages-header .window-control {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            border: none;
        }

        .messages-header .window-control.close {
            background-color: #FF5F56;
        }

        .messages-header .window-control.minimize {
            background-color: #FFBD2E;
        }

        .messages-header .window-control.maximize {
            background-color: #27C93F;
        }

        .messages-header .chat-title {
            display: flex;
            align-items: center;
            gap: 8px;
            font-weight: 600;
            color: var(--primary-color);
            font-size: 0.95rem;
        }

        .messages-header .chat-title img {
            width: 16px;
            height: 16px;
        }

        .messages-header .flex-1 {
            flex: 1;
        }

        .messages-header input {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid #D1D5DB;
            border-radius: 8px;
            font-family: monospace;
            font-size: 0.875rem;
            transition: all 0.2s ease;
            background: rgba(255, 255, 255, 0.8);
            color: var(--primary-color);
        }

        [data-theme="dark"] .messages-header input {
            background: rgba(45, 55, 72, 0.8);
            border-color: #4A5568;
            color: var(--primary-color);
        }

        .messages-header input:focus {
            outline: none;
            border-color: #8B5CF6;
            box-shadow: 0 0 0 2px rgba(139, 92, 246, 0.2);
        }

        .messages-container {
            padding: 16px;
            background: transparent;
            flex: 1;
            overflow-y: auto;
            max-height: calc(100% - 140px);
        }

        .message {
            max-width: 85%;
            padding: 12px 16px;
            margin-bottom: 12px;
            border-radius: 16px;
            word-wrap: break-word;
            animation: fadeIn 0.3s ease;
            position: relative;
            line-height: 1.4;
            font-size: 0.95rem;
            font-weight: 500;
        }

        .message.sent {
            background: linear-gradient(135deg, #8B5CF6, #3B82F6);
            color: #FFFFFF;
            margin-left: auto;
            border-bottom-right-radius: 6px;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
            box-shadow: 0 2px 8px rgba(139, 92, 246, 0.2);
        }

        .message.received {
            background-color: #F8F9FA;
            color: #374151;
            border-bottom-left-radius: 6px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
        }

        [data-theme="dark"] .message.received {
            background-color: #2D3748;
            color: #E2E8F0;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        }

        .message .meta {
            font-size: 0.75rem;
            opacity: 0.8;
            margin-top: 6px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .message.sent .meta {
            color: rgba(255, 255, 255, 0.9);
            text-shadow: none;
        }

        .message.received .meta {
            color: #6B7280;
        }

        [data-theme="dark"] .message.received .meta {
            color: #A0AEC0;
        }

        .message-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 4px;
            font-size: 0.75rem;
            opacity: 0.8;
        }

        .message.sent .message-header {
            color: rgba(255, 255, 255, 0.9);
        }

        .message.received .message-header {
            color: #6B7280;
        }

        [data-theme="dark"] .message.received .message-header {
            color: #A0AEC0;
        }

        .message-header .sender {
            font-weight: 600;
        }

        .message-header .timestamp {
            font-size: 0.7rem;
        }

        .message-content {
            word-wrap: break-word;
            line-height: 1.4;
        }

        .input-area {
            padding: 16px;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-top: 1px solid rgba(255, 255, 255, 0.3);
            display: flex;
            gap: 12px;
            position: sticky;
            bottom: 0;
            z-index: 1;
        }

        [data-theme="dark"] .input-area {
            background: rgba(26, 32, 44, 0.95);
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        input {
            width: 100%;
            padding: 12px 16px;
            border: 1px solid var(--light-gray);
            border-radius: 12px;
            font-size: 0.95rem;
            background-color: rgba(255, 255, 255, 0.8);
            color: var(--primary-color);
            transition: var(--transition);
        }

        [data-theme="dark"] input {
            background-color: rgba(45, 55, 72, 0.8);
            border-color: #4A5568;
            color: var(--primary-color);
        }

        input:focus {
            outline: none;
            border-color: var(--accent-color);
            box-shadow: 0 0 0 2px rgba(0, 136, 148, 0.2);
        }

        #recipientAddress {
            font-family: monospace;
            font-size: 0.9rem;
            letter-spacing: 0.5px;
        }

        .typing-indicator {
            display: flex;
            justify-content: center;
            gap: 4px;
            margin-top: 8px;
        }

        .typing-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background-color: #8B5CF6;
            animation: typingPulse 1.5s infinite;
        }

        .typing-dot:nth-child(2) {
            animation-delay: 0.2s;
        }

        .typing-dot:nth-child(3) {
            animation-delay: 0.4s;
        }

        @keyframes typingPulse {

            0%,
            60%,
            100% {
                opacity: 0.3;
                transform: scale(0.8);
            }

            30% {
                opacity: 1;
                transform: scale(1.1);
            }
        }

        .connection-status {
            margin-top: var(--spacing);
            padding: 10px 16px;
            border-radius: 30px;
            background: rgba(255, 255, 255, 0.8);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.3);
            display: inline-flex;
            align-items: center;
            gap: 8px;
            box-shadow: 0 4px 16px rgba(139, 92, 246, 0.1);
            font-size: 0.9rem;
            font-weight: 500;
        }

        .status-indicator {
            width: 10px;
            height: 10px;
            border-radius: 50%;
        }

        .status-indicator.online {
            background-color: var(--accent-color);
            box-shadow: 0 0 12px var(--accent-color);
        }

        .status-indicator.offline {
            background-color: #FF6B6B;
            box-shadow: 0 0 12px #FF6B6B;
        }

        .status-indicator.connecting {
            background-color: #FFA502;
            box-shadow: 0 0 12px #FFA502;
            animation: pulse 1.5s infinite;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes pulse {
            0% {
                opacity: 0.5;
                transform: scale(0.8);
            }

            50% {
                opacity: 1;
                transform: scale(1.1);
            }

            100% {
                opacity: 0.5;
                transform: scale(0.8);
            }
        }

        .wallet-info {
            background: rgba(255, 255, 255, 0.8);
            backdrop-filter: blur(10px);
            padding: var(--spacing);
            border-radius: 12px;
            margin-top: var(--spacing);
            border: 1px solid rgba(255, 255, 255, 0.3);
            text-align: left;
            box-shadow: 0 4px 16px rgba(139, 92, 246, 0.1);
        }

        .wallet-info p {
            margin-bottom: 8px;
        }

        .wallet-info code {
            background-color: var(--light-gray);
            padding: 4px 8px;
            border-radius: 4px;
            font-family: monospace;
            word-break: break-all;
            display: inline-block;
            margin-top: 4px;
        }

        .wallet-info .active {
            color: var(--accent-color);
            font-weight: 500;
        }

        /* Custom scrollbar */
        ::-webkit-scrollbar {
            width: 6px;
        }

        ::-webkit-scrollbar-track {
            background: transparent;
        }

        ::-webkit-scrollbar-thumb {
            background: var(--secondary-color);
            border-radius: 3px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--accent-color);
        }

        /* Mobile responsiveness */
        @media (max-width: 768px) {
            .chat-wrapper {
                grid-template-columns: 1fr;
                height: 100%;
            }

            .conversations-list {
                display: none;
            }

            .container {
                padding: 0;
            }

            .header {
                padding: 12px 16px;
            }

            .connect-section {
                padding: 16px;
            }

            .chat-section {
                height: calc(100vh - 180px);
            }
        }

        /* Info section migliorata */
        .info .flex {
            display: flex;
        }

        .info .items-center {
            align-items: center;
        }

        .info .space-x-2>*+* {
            margin-left: 8px;
        }

        .info .mb-3 {
            margin-bottom: 12px;
        }

        .info .h-2 {
            height: 8px;
        }

        .info .w-2 {
            width: 8px;
        }

        .info .rounded-full {
            border-radius: 50%;
        }

        .info span {
            font-weight: 600;
            color: var(--primary-color);
        }

        .info ul {
            margin-left: 0;
            padding-left: 0;
            list-style: none;
        }

        .info li {
            margin-bottom: 8px;
            padding-left: 4px;
        }

        /* Utility classes per le immagini */
        .h-6 {
            height: 24px;
        }

        .w-6 {
            width: 24px;
        }

        .h-8 {
            height: 32px;
        }

        .w-8 {
            width: 32px;
        }

        .h-12 {
            height: 48px;
        }

        .w-12 {
            width: 48px;
        }

        /* Assicura che tutti gli elementi rotondi siano perfettamente circolari */
        .theme-toggle,
        .window-control,
        .typing-dot,
        .status-indicator,
        .info .rounded-full {
            aspect-ratio: 1;
            flex-shrink: 0;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* Assicura che le immagini mantengano le proporzioni */
        img {
            object-fit: contain;
        }

        /* Modal styles */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(5px);
        }

        .modal-content {
            background-color: var(--bg-color);
            margin: 5% auto;
            padding: 20px;
            border-radius: 16px;
            width: 90%;
            max-width: 500px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.3);
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 1px solid var(--light-gray);
        }

        .modal-header h2 {
            margin: 0;
            color: var(--primary-color);
            font-size: 1.5rem;
        }

        .close {
            color: var(--secondary-color);
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
            transition: var(--transition);
        }

        .close:hover {
            color: var(--primary-color);
        }

        .modal-body {
            margin-bottom: 20px;
        }

        .modal-body label {
            display: block;
            margin-bottom: 8px;
            font-weight: 500;
            color: var(--primary-color);
        }

        .modal-body input {
            width: 100%;
            padding: 12px;
            border: 1px solid var(--light-gray);
            border-radius: 8px;
            margin-bottom: 15px;
            font-size: 0.95rem;
            background-color: var(--bg-color);
            color: var(--primary-color);
        }

        .modal-body textarea {
            width: 100%;
            min-height: 150px;
            padding: 12px;
            border: 1px solid var(--light-gray);
            border-radius: 8px;
            margin-bottom: 15px;
            font-size: 0.9rem;
            font-family: monospace;
            background-color: var(--bg-color);
            color: var(--primary-color);
            resize: vertical;
        }

        .modal-footer {
            display: flex;
            justify-content: flex-end;
            gap: 12px;
        }

        .modal-footer button {
            min-width: 100px;
        }

        .btn-secondary {
            background-color: var(--secondary-color);
            color: white;
        }

        .btn-secondary:hover {
            background-color: var(--primary-color);
        }

        .backup-info {
            background-color: var(--light-gray);
            padding: 12px;
            border-radius: 8px;
            margin-bottom: 15px;
            font-size: 0.9rem;
            color: var(--secondary-color);
        }

        .warning-text {
            color: #FF6B6B;
            font-weight: 500;
            margin-bottom: 10px;
        }

        /* Tab styles for restore modal */
        .tab-button {
            background: var(--light-gray);
            border: 1px solid var(--secondary-color);
            color: var(--primary-color);
            padding: 8px 16px;
            margin-right: 8px;
            border-radius: 6px;
            cursor: pointer;
            transition: var(--transition);
            font-size: 0.9rem;
        }

        .tab-button.active {
            background: var(--accent-color);
            color: white;
            border-color: var(--accent-color);
        }

        .tab-button:hover {
            background: var(--accent-color);
            color: white;
        }

        .tab-content {
            display: block;
        }

        .tab-content.hidden {
            display: none;
        }

        [data-theme="dark"] .conversations-list {
            background: rgba(45, 55, 72, 0.8);
            border-right: 1px solid rgba(255, 255, 255, 0.1);
        }

        [data-theme="dark"] .conversations-header {
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        [data-theme="dark"] .conversations-header h3 {
            color: var(--primary-color-dark);
        }
    </style>
</head>

<body>
    <div class="container">
        <div class="header">
            <div class="flex items-center space-x-3">
                <img src="logo.svg" alt="Shogun Logo" class="h-12 w-12" />
                <div>
                    <h1
                        class="text-2xl font-bold bg-gradient-to-r from-purple-600 to-blue-600 bg-clip-text text-transparent">
                        d3
                    </h1>
                    <p class="text-sm text-gray-600">Decentralized Chat</p>
                </div>
            </div>
            <button class="theme-toggle" id="themeToggle">üåô</button>
        </div>

        <div id="wallet-section" class="connect-section">
            <div class="button-group">
                <div class="flex items-center space-x-2 mb-4">
                    <img src="logo.svg" alt="Shogun" class="h-8 w-8" />
                    <span
                        class="text-lg font-bold bg-gradient-to-r from-purple-600 to-blue-600 bg-clip-text text-transparent">
                        Connect to Shogun Network
                    </span>
                </div>

                <div class="flex flex-wrap gap-3 justify-center">
                    <button id="connectWallet"
                        class="bg-gradient-to-r from-purple-600 to-blue-600 hover:from-purple-700 hover:to-blue-700 text-white px-6 py-3 rounded-lg font-medium transition-all duration-200 transform hover:scale-105 shadow-lg">
                        üîó Connect Wallet
                    </button>
                    <button id="refreshChat"
                        class="bg-gradient-to-r from-gray-600 to-gray-700 hover:from-gray-700 hover:to-gray-800 text-white px-6 py-3 rounded-lg font-medium transition-all duration-200 transform hover:scale-105 shadow-lg">
                        üîÑ Refresh Chat
                    </button>
                    <button id="disconnectWallet"
                        class="bg-gradient-to-r from-red-600 to-red-700 hover:from-red-700 hover:to-red-800 text-white px-6 py-3 rounded-lg font-medium transition-all duration-200 transform hover:scale-105 shadow-lg"
                        style="display: none;">
                        üö™ Disconnect
                    </button>
                </div>
            </div>

            <!-- ‚úÖ NUOVO: Sezione separata per i pulsanti di debug e utility -->
            <div class="debug-buttons">
                <button id="backupKeypair"
                    class="bg-gradient-to-r from-green-600 to-green-700 hover:from-green-700 hover:to-green-800 text-white px-6 py-3 rounded-lg font-medium transition-all duration-200 transform hover:scale-105 shadow-lg"
                    style="display: none;">
                    üíæ Backup Keypair
                </button>
                <button id="registerKeypair"
                    class="bg-gradient-to-r from-blue-600 to-blue-700 hover:from-blue-700 hover:to-blue-800 text-white px-6 py-3 rounded-lg font-medium transition-all duration-200 transform hover:scale-105 shadow-lg">
                    üîë Register Keypair
                </button>
                <button id="debugKeypair"
                    class="bg-gradient-to-r from-yellow-600 to-yellow-700 hover:from-yellow-700 hover:to-yellow-800 text-white px-6 py-3 rounded-lg font-medium transition-all duration-200 transform hover:scale-105 shadow-lg">
                    üîç Debug Keypair
                </button>
                <button id="clearAllMessages"
                    class="bg-gradient-to-r from-red-600 to-red-700 hover:from-red-700 hover:to-red-800 text-white px-6 py-3 rounded-lg font-medium transition-all duration-200 transform hover:scale-105 shadow-lg">
                    üóëÔ∏è Clear All Messages
                </button>
                <button id="restoreKeypair"
                    class="bg-gradient-to-r from-orange-600 to-orange-700 hover:from-orange-700 hover:to-orange-800 text-white px-6 py-3 rounded-lg font-medium transition-all duration-200 transform hover:scale-105 shadow-lg">
                    üìÇ Restore Keypair
                </button>
            </div>

            <div class="status-group">
                <div id="walletInfo" class="wallet-info"
                    style="margin: 0; padding: 8px 16px; background: rgba(34, 197, 94, 0.1); border: 1px solid rgba(34, 197, 94, 0.2); border-radius: 20px; color: #22C55E; font-size: 0.9rem;">
                </div>

                <div class="connection-status" id="gunStatus"
                    style="margin: 0; padding: 8px 16px; background: rgba(139, 92, 246, 0.1); border: 1px solid rgba(139, 92, 246, 0.2); border-radius: 20px; color: #8B5CF6; font-size: 0.9rem;">
                    <span class="status-indicator connecting"></span>
                    <span>Connecting to Gun Network...</span>
                </div>

                <div style="font-size: 0.85rem;">
                    <div class="flex items-center justify-center space-x-2">
                        <span class="text-gray-600">Debug:</span>
                        <select id="logLevel"
                            class="px-3 py-1 rounded-md bg-white border border-gray-300 text-gray-700 focus:ring-2 focus:ring-purple-500 focus:border-transparent text-sm">
                            <option value="none">None</option>
                            <option value="error">Error</option>
                            <option value="warn">Warning</option>
                            <option value="info" selected>Info</option>
                            <option value="debug">Debug</option>
                            <option value="verbose">Verbose</option>
                        </select>
                    </div>
                </div>
            </div>
        </div>

        <div id="chatSection" class="chat-section">
            <div class="chat-wrapper">
                <div class="conversations-list" id="conversationsList">
                    <div class="conversations-header">
                        <h3>Conversations</h3>
                        <button class="new-conversation-btn" onclick="openNewConversationModal()">New
                            Conversation</button>
                    </div>
                    <div class="conversations-content" id="conversationsContent">
                        <!-- Conversations will appear here -->
                    </div>
                </div>
                <div class="messages">
                    <div class="messages-header">
                        <div class="window-controls">
                            <div class="window-control close"></div>
                            <div class="window-control minimize"></div>
                            <div class="window-control maximize"></div>
                        </div>
                        <div class="chat-title">
                            <img src="logo.svg" alt="Shogun" />
                            <span>Shogun-D3 Chat</span>
                        </div>
                        <div class="flex-1">
                            <input type="text" id="recipientAddress" placeholder="Enter recipient's ETH address (0x...)"
                                class="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-purple-500 focus:border-transparent text-sm font-mono">
                        </div>
                        <button id="refreshConversation"
                            class="ml-2 px-3 py-2 bg-gradient-to-r from-purple-600 to-blue-600 text-white rounded-lg text-sm font-medium hover:from-purple-700 hover:to-blue-700 transition-all duration-200"
                            title="Refresh conversation in chronological order">
                            üîÑ
                        </button>
                    </div>
                    <div class="messages-container" id="messagesContainer">
                        <!-- Messages will appear here -->
                    </div>
                    <div class="input-area">
                        <input type="text" id="messageInput" placeholder="Type a message...">
                        <button id="sendMessage">Send</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Backup Keypair Modal -->
    <div id="backupModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>üíæ Backup Keypair</h2>
                <span class="close" onclick="closeBackupModal()">&times;</span>
            </div>
            <div class="modal-body">
                <div class="backup-info">
                    <strong>‚ö†Ô∏è Important:</strong> This backup contains your private keys. Store it securely and never
                    share it with anyone.
                </div>

                <label for="backupPassword">Password (optional, but recommended):</label>
                <input type="password" id="backupPassword" placeholder="Enter a strong password to encrypt your backup">

                <label for="backupData">Backup Data:</label>
                <textarea id="backupData" readonly placeholder="Your backup data will appear here..."></textarea>

                <div style="text-align: center; margin-top: 10px;">
                    <button type="button" onclick="downloadBackup()"
                        style="background: linear-gradient(135deg, #10B981, #059669); margin-right: 10px;">
                        üì• Download as File
                    </button>
                    <button type="button" onclick="copyBackupToClipboard()"
                        style="background: linear-gradient(135deg, #6366F1, #4F46E5);">
                        üìã Copy to Clipboard
                    </button>
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn-secondary" onclick="closeBackupModal()">Close</button>
                <button type="button" onclick="generateBackup()">Create Backup</button>
            </div>
        </div>
    </div>

    <!-- Restore Keypair Modal -->
    <div id="restoreModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>üìÇ Restore Keypair</h2>
                <span class="close" onclick="closeRestoreModal()">&times;</span>
            </div>
            <div class="modal-body">
                <div class="warning-text">
                    ‚ö†Ô∏è Warning: Restoring a keypair will replace your current keypair. Make sure you have a backup
                    first!
                </div>

                <!-- Tab buttons -->
                <div style="margin-bottom: 20px;">
                    <button type="button" id="restoreTabBackup" class="tab-button active"
                        onclick="switchRestoreTab('backup')">
                        üìÅ From Backup File
                    </button>
                    <button type="button" id="restoreTabManual" class="tab-button" onclick="switchRestoreTab('manual')">
                        ‚úèÔ∏è Manual Input
                    </button>
                </div>

                <!-- Backup tab content -->
                <div id="restoreBackupTab" class="tab-content">
                    <label for="restoreData">Backup Data:</label>
                    <textarea id="restoreData" placeholder="Paste your backup data here..."></textarea>

                    <label for="restorePassword">Password (if you used one during backup):</label>
                    <input type="password" id="restorePassword" placeholder="Enter the password used for encryption">

                    <div style="text-align: center; margin-top: 10px;">
                        <input type="file" id="restoreFile" accept=".json,.txt" style="display: none;"
                            onchange="loadBackupFile(event)">
                        <button type="button" onclick="document.getElementById('restoreFile').click()"
                            style="background: linear-gradient(135deg, #8B5CF6, #7C3AED);">
                            üìÅ Load from File
                        </button>
                    </div>
                </div>

                <!-- Manual tab content -->
                <div id="restoreManualTab" class="tab-content" style="display: none;">
                    <label for="restorePub">Public Key (pub):</label>
                    <input type="text" id="restorePub" placeholder="Enter the public key (pub)">

                    <label for="restorePriv">Private Key (priv):</label>
                    <input type="password" id="restorePriv" placeholder="Enter the private key (priv)">

                    <label for="restoreEpub">Encrypted Public Key (epub):</label>
                    <input type="text" id="restoreEpub" placeholder="Enter the encrypted public key (epub)">

                    <label for="restoreEpriv">Encrypted Private Key (epriv):</label>
                    <input type="password" id="restoreEpriv" placeholder="Enter the encrypted private key (epriv)">

                    <div style="text-align: center; margin-top: 10px;">
                        <button type="button" onclick="populateFromCurrentKeypair()"
                            style="background: linear-gradient(135deg, #10B981, #059669); margin-right: 10px;">
                            üîç Load Current Keypair Values
                        </button>
                    </div>

                    <div
                        style="margin-top: 15px; padding: 10px; background-color: var(--light-gray); border-radius: 8px; font-size: 0.9rem;">
                        <strong>üí° Tip:</strong> You can find these values in your backup file or by using the "Debug
                        Keypair" button to see the current keypair structure. Click "Load Current Keypair Values" to
                        populate fields with your current keypair for easy copying.
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn-secondary" onclick="closeRestoreModal()">Cancel</button>
                <button type="button" onclick="performRestore()">Restore Keypair</button>
            </div>
        </div>
    </div>

    <!-- Required libraries -->
    <script src="https://cdn.jsdelivr.net/npm/gun/gun.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/gun/sea.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/ethers@5.7.0/dist/ethers.umd.min.js"></script>
    <!-- ‚úÖ AGGIORNATO: Carica ShogunCore prima di d3.js -->
    <script src="https://cdn.jsdelivr.net/npm/shogun-core@^1.6.15/dist/browser/shogun-core.js"></script>
    <!-- d3.js content included inline -->
    <script src="d3.js"></script>
    <script>
        // Theme toggle functionality
        const themeToggle = document.getElementById('themeToggle');
        const prefersDarkScheme = window.matchMedia('(prefers-color-scheme: dark)');

        // Set initial theme based on system preference
        if (prefersDarkScheme.matches) {
            document.body.setAttribute('data-theme', 'dark');
            themeToggle.textContent = '‚òÄÔ∏è';
        }

        themeToggle.addEventListener('click', () => {
            const currentTheme = document.body.getAttribute('data-theme');
            if (currentTheme === 'dark') {
                document.body.removeAttribute('data-theme');
                themeToggle.textContent = 'üåô';
            } else {
                document.body.setAttribute('data-theme', 'dark');
                themeToggle.textContent = '‚òÄÔ∏è';
            }
        });

        // Check if d3 and d3.debug exist, otherwise initialize
        if (!window.d3) {
            console.error("Error: d3 object not loaded correctly");
            window.d3 = {};
        }

        if (!window.d3.debug) {
            console.warn("Warning: d3.debug object not found, initializing");
            window.d3.debug = {};
        }

        // Check if testGunConnection exists, otherwise create it
        if (!window.d3.debug.testGunConnection) {
            console.warn("Warning: testGunConnection function not found, creating");
            window.d3.debug.testGunConnection = async function () {
                try {
                    const startTime = Date.now();

                    // Test Gun connection with a simple ping
                    const result = await new Promise((resolve) => {
                        const timeoutId = setTimeout(() => {
                            resolve({
                                success: false,
                                message: "Connection test timeout"
                            });
                        }, 5000);

                        // Try to read data from Gun
                        window.gun.get("connection_test").once((data) => {
                            clearTimeout(timeoutId);
                            resolve({
                                success: true
                            });
                        });
                    });

                    const endTime = Date.now();
                    const latency = endTime - startTime;

                    return {
                        ...result,
                        latency
                    };
                } catch (error) {
                    return {
                        success: false,
                        message: error.message || "Error during connection test"
                    };
                }
            };
        }

        // DOM Elements
        const connectWalletBtn = document.getElementById('connectWallet');
        const walletInfoEl = document.getElementById('walletInfo');
        const chatSection = document.getElementById('chatSection');
        const recipientAddressInput = document.getElementById('recipientAddress');
        const messagesContainer = document.getElementById('messagesContainer');
        const messageInput = document.getElementById('messageInput');
        const sendMessageBtn = document.getElementById('sendMessage');
        const keyPairStatusElement = document.createElement('div');
        walletInfoEl.appendChild(keyPairStatusElement);

        // Global variables
        let userAddress = null;
        let provider = null;
        let wallet = null;
        let gunKeyPair = null;
        let activeConversations = new Set();
        let processedMessages = new Set();
        let chatMessages = {};
        let conversations = new Map(); // Store conversation data

        // Function to add or update a conversation
        const addConversation = (address, lastMessage = '', messageCount = 0) => {
            if (!address || address.toLowerCase() === userAddress?.toLowerCase()) {
                return; // Don't add self as conversation
            }

            const normalizedAddress = address.toLowerCase();
            const existing = conversations.get(normalizedAddress);

            if (existing) {
                existing.lastMessage = lastMessage || existing.lastMessage;
                existing.messageCount = existing.messageCount + (messageCount || 0);
                existing.lastActivity = Date.now();
            } else {
                conversations.set(normalizedAddress, {
                    address: address,
                    lastMessage: lastMessage,
                    messageCount: messageCount || 0,
                    lastActivity: Date.now()
                });
            }

            updateConversationsList();
        };

        // Function to update the conversations list in the sidebar
        const updateConversationsList = () => {
            const conversationsContent = document.getElementById('conversationsContent');
            if (!conversationsContent) return;

            // Sort conversations by last activity (most recent first)
            const sortedConversations = Array.from(conversations.values())
                .sort((a, b) => b.lastActivity - a.lastActivity);

            if (sortedConversations.length === 0) {
                conversationsContent.innerHTML = `
                    <div style="text-align: center; padding: 20px; color: var(--secondary-color);">
                        <div style="font-size: 2rem; margin-bottom: 10px;">üí¨</div>
                        <div>No conversations yet</div>
                        <div style="font-size: 0.8rem; margin-top: 5px;">Start a chat by entering an address</div>
                    </div>
                `;
                return;
            }

            conversationsContent.innerHTML = sortedConversations.map(conv => {
                const shortAddress = `${conv.address.slice(0, 6)}...${conv.address.slice(-4)}`;
                const lastMessagePreview = conv.lastMessage.length > 30
                    ? conv.lastMessage.substring(0, 30) + '...'
                    : conv.lastMessage;

                return `
                    <div class="conversation-item" data-address="${conv.address}" onclick="selectConversation('${conv.address}')">
                        <div class="address">${shortAddress}</div>
                        <div class="message-count">${conv.messageCount} message${conv.messageCount !== 1 ? 's' : ''}</div>
                        <div class="last-message">${lastMessagePreview || 'No messages yet'}</div>
                    </div>
                `;
            }).join('');
        };

        // Function to reorder existing messages chronologically
        const reorderMessages = () => {
            const existingMessages = Array.from(messagesContainer.children);
            if (existingMessages.length <= 1) return;

            // Sort messages by their timestamp
            const sortedMessages = existingMessages.sort((a, b) => {
                const timestampA = parseInt(a.dataset.timestamp) || 0;
                const timestampB = parseInt(b.dataset.timestamp) || 0;
                return timestampA - timestampB;
            });

            // Clear container and re-add messages in correct order
            messagesContainer.innerHTML = '';
            sortedMessages.forEach(message => {
                messagesContainer.appendChild(message);
            });

            // Scroll to bottom
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
        };

        // Function to refresh current conversation
        const refreshCurrentConversation = () => {
            const currentRecipient = recipientAddressInput.value.trim();
            if (currentRecipient) {
                selectConversation(currentRecipient);
            }
        };

        // Function to select a conversation
        window.selectConversation = async (address) => {
            // Update recipient address input
            document.getElementById('recipientAddress').value = address;

            // Update active conversation styling
            document.querySelectorAll('.conversation-item').forEach(item => {
                item.classList.remove('active');
            });

            const selectedItem = document.querySelector(`[data-address="${address}"]`);
            if (selectedItem) {
                selectedItem.classList.add('active');
            }

            // Clear messages container and load conversation history
            messagesContainer.innerHTML = '';

            // Load messages for this conversation from localStorage
            const conversationKey = [userAddress, address].sort().join('_');
            const savedMessages = chatMessages[conversationKey] || [];

            // üîç NUOVO: Pulisci i messaggi duplicati prima di visualizzarli
            const cleanedMessages = cleanDuplicateMessages(savedMessages);
            console.log(`üîç Caricati ${cleanedMessages.length} messaggi (${savedMessages.length - cleanedMessages.length} duplicati rimossi)`);

            // ‚úÖ NUOVO: Ordina i messaggi per timestamp prima di visualizzarli
            const sortedMessages = cleanedMessages.sort((a, b) => {
                const timestampA = a.date || a.timestamp || 0;
                const timestampB = b.date || b.timestamp || 0;
                return timestampA - timestampB;
            });

            // Visualizza i messaggi in ordine cronologico
            sortedMessages.forEach(msg => {
                const isFromMe = msg.from?.toLowerCase() === userAddress?.toLowerCase();
                displayMessage(msg, isFromMe);
            });

            // üîç NUOVO: Verifica e registra automaticamente il keypair se necessario
            try {
                console.log("üîç Verificando keypair per conversazione:", address);
                const keypairStatus = await d3.debugKeypairStatus(address);

                if (!keypairStatus.hasKeypairInDatabase && keypairStatus.isCurrentUser) {
                    console.log("üîÑ Keypair non trovato per utente corrente, registrando automaticamente...");
                    const registrationResult = await d3.forceRegisterKeypair(address);
                    if (registrationResult) {
                        console.log("‚úÖ Keypair registrato automaticamente per conversazione");
                    } else {
                        console.warn("‚ö†Ô∏è Registrazione automatica fallita per conversazione");
                    }
                } else if (!keypairStatus.hasKeypairInDatabase) {
                    console.warn("‚ö†Ô∏è Keypair non trovato per destinatario:", address);
                    console.log("üí° Il destinatario deve registrare il proprio keypair per ricevere messaggi crittografati");
                }
            } catch (error) {
                console.error("‚ùå Errore durante la verifica keypair per conversazione:", error);
            }

            // Set up message reception for this specific recipient
            handleRecipientChange();
        };

        // Function to open new conversation modal
        window.openNewConversationModal = () => {
            const address = prompt('Enter the Ethereum address to start a conversation with:');
            if (address && address.trim()) {
                const cleanAddress = address.trim();

                // Validate Ethereum address format
                if (!/^0x[a-fA-F0-9]{40}$/.test(cleanAddress)) {
                    alert('Please enter a valid Ethereum address (0x followed by 40 hexadecimal characters)');
                    return;
                }

                // Add conversation and select it
                addConversation(cleanAddress, '', 0);
                selectConversation(cleanAddress);
            }
        };

        // LocalStorage functions
        const saveMessagesToLocalStorage = () => {
            try {
                localStorage.setItem('shogun_d3_chat_messages', JSON.stringify(chatMessages));
                console.log('Messages saved to localStorage');
            } catch (error) {
                console.error('Error saving messages to localStorage:', error);
            }
        };

        const loadMessagesFromLocalStorage = () => {
            try {
                let saved = localStorage.getItem('shogun_d3_chat_messages');
                if (!saved) {
                    saved = localStorage.getItem('succus_chat_messages');
                }

                if (saved) {
                    chatMessages = JSON.parse(saved);
                    console.log('Messages loaded from localStorage:', Object.keys(chatMessages).length, 'conversations found');
                    return true;
                }
            } catch (error) {
                console.error('Error loading messages from localStorage:', error);
            }
            return false;
        };

        // Load messages from localStorage on startup
        loadMessagesFromLocalStorage();

        // Function to check Gun status
        const checkGunStatus = async () => {
            try {
                const status = await window.d3.debug.testGunConnection();
                const statusElement = document.getElementById('gunStatus');

                if (status.success) {
                    statusElement.innerHTML = `
                        <span class="status-indicator online"></span>
                        <span>Gun connected (latency: ${status.latency}ms)</span>
                    `;
                    return true;
                } else {
                    statusElement.innerHTML = `
                        <span class="status-indicator offline"></span>
                        <span>Gun disconnected: ${status.message}</span>
                    `;
                    return false;
                }
            } catch (error) {
                document.getElementById('gunStatus').innerHTML = `
                    <span class="status-indicator offline"></span>
                    <span>Gun error: ${error.message}</span>
                `;
                return false;
            }
        };

        // Function to handle offline message sending
        const handleOfflineMessageSending = (message, recipientAddress) => {
            console.log('GunDB is offline, storing message locally for later delivery');

            // Store message in localStorage for later delivery
            const offlineMessages = JSON.parse(localStorage.getItem('shogun_offline_messages') || '[]');
            offlineMessages.push({
                message: message,
                recipient: recipientAddress,
                timestamp: Date.now(),
                userAddress: userAddress
            });
            localStorage.setItem('shogun_offline_messages', JSON.stringify(offlineMessages));

            // Show offline indicator
            const statusElement = document.getElementById('gunStatus');
            statusElement.innerHTML = `
                <span class="status-indicator offline"></span>
                <span>Message stored offline (${offlineMessages.length} pending)</span>
            `;
        };

        // Function to retry sending offline messages
        const retryOfflineMessages = async () => {
            const offlineMessages = JSON.parse(localStorage.getItem('shogun_offline_messages') || '[]');
            if (offlineMessages.length === 0) return;

            console.log(`Attempting to send ${offlineMessages.length} offline messages`);

            const successfulMessages = [];
            const failedMessages = [];

            for (const offlineMsg of offlineMessages) {
                try {
                    const result = await d3.sendmessage(offlineMsg.message, [offlineMsg.recipient], gunKeyPair);
                    if (result.sent) {
                        successfulMessages.push(offlineMsg);
                    } else {
                        failedMessages.push(offlineMsg);
                    }
                } catch (error) {
                    failedMessages.push(offlineMsg);
                }
            }

            // Update localStorage with only failed messages
            localStorage.setItem('shogun_offline_messages', JSON.stringify(failedMessages));

            if (successfulMessages.length > 0) {
                console.log(`Successfully sent ${successfulMessages.length} offline messages`);
            }

            if (failedMessages.length > 0) {
                console.log(`${failedMessages.length} messages still pending delivery`);
            }
        };

        // Function to clear all messages from Gun and localStorage
        const clearAllMessages = async () => {
            if (!userAddress) {
                alert("Please connect your wallet first.");
                return;
            }

            // Chiedi conferma all'utente
            const confirmed = confirm(
                "‚ö†Ô∏è ATTENTION: This will permanently delete ALL messages from Gun network and localStorage.\n\n" +
                "This action cannot be undone. Are you sure you want to continue?"
            );

            if (!confirmed) {
                return;
            }

            try {
                console.log("üóëÔ∏è Starting to clear all messages...");

                // 1. Cancella tutti i messaggi da Gun
                const conversationsToClear = Array.from(conversations.keys());
                let gunClearedCount = 0;

                for (const address of conversationsToClear) {
                    try {
                        // Genera il namespace della conversazione
                        const normalizedUser = userAddress.toLowerCase();
                        const normalizedRecipient = address.toLowerCase();
                        const participants = [normalizedRecipient, normalizedUser].sort();
                        const sortedParticipants = participants.join("");
                        const chatNamespace = window.d3.HashNamespace(sortedParticipants);

                        // Cancella tutti i messaggi in questo namespace
                        const chatRef = window.gun.get("shogun").get(chatNamespace);

                        // Mappa tutti i messaggi e li cancella
                        chatRef.map().once((data, key) => {
                            if (key !== "_" && data) {
                                chatRef.get(key).put(null);
                                gunClearedCount++;
                            }
                        });

                        console.log(`üóëÔ∏è Cleared messages for conversation with ${address}`);
                    } catch (error) {
                        console.error(`‚ùå Error clearing messages for ${address}:`, error);
                    }
                }

                // 2. Cancella tutti i messaggi da localStorage
                const localStorageKeys = [
                    'shogun_d3_chat_messages',
                    'succus_chat_messages',
                    'shogun_offline_messages'
                ];

                let localStorageClearedCount = 0;
                localStorageKeys.forEach(key => {
                    const data = localStorage.getItem(key);
                    if (data) {
                        try {
                            const parsedData = JSON.parse(data);
                            if (typeof parsedData === 'object') {
                                localStorageClearedCount += Object.keys(parsedData).length;
                            }
                        } catch (e) {
                            // Se non √® JSON, conta come 1 elemento
                            localStorageClearedCount++;
                        }
                        localStorage.removeItem(key);
                    }
                });

                // 3. Pulisci le variabili locali
                chatMessages = {};
                conversations.clear();
                messagesContainer.innerHTML = '';
                updateConversationsList();

                // 4. Mostra il risultato
                const message = `‚úÖ Messages cleared successfully!\n\n` +
                    `üóëÔ∏è Gun Network: ${gunClearedCount} messages cleared\n` +
                    `üíæ LocalStorage: ${localStorageClearedCount} items cleared\n\n` +
                    `All conversations and messages have been permanently deleted.`;

                alert(message);
                console.log("üóëÔ∏è All messages cleared successfully");

            } catch (error) {
                console.error("‚ùå Error clearing messages:", error);
                alert("‚ùå Error clearing messages: " + error.message);
            }
        };

        // Function to disconnect wallet
        const disconnectWallet = () => {
            // Reset all variables
            userAddress = null;
            gunKeyPair = null;
            window.currentUserAddress = null;
            window.gunKeyPair = null;

            // Remove connected class
            const walletSection = document.getElementById('wallet-section');
            walletSection.classList.remove('connected');

            // ‚úÖ AGGIORNATO: Mostra pulsante connessione e nascondi disconnessione
            document.getElementById('connectWallet').style.display = 'inline-block';
            document.getElementById('disconnectWallet').style.display = 'none';

            // ‚úÖ NUOVO: Nascondi il pulsante backup quando disconnesso
            document.getElementById('backupKeypair').style.display = 'none';

            // Reset wallet info
            walletInfoEl.innerHTML = '';
            keyPairStatusElement.innerHTML = '';

            // Hide chat section
            chatSection.style.display = 'none';

            // Clear conversations
            conversations.clear();
            updateConversationsList();

            // Clear messages
            messagesContainer.innerHTML = '';

            console.log('Wallet disconnected');
        };

        // Function to connect wallet
        const connectWallet = async () => {
            try {
                const result = await d3.connectWithMetaMask();

                if (!result || !result.address) {
                    console.error("Connection error: invalid result", result);
                    return;
                }

                userAddress = result.address;
                gunKeyPair = result.keypair;

                window.currentUserAddress = userAddress;
                window.gunKeyPair = gunKeyPair;

                // Add connected class to hide buttons and show status
                const walletSection = document.getElementById('wallet-section');
                walletSection.classList.add('connected');

                // ‚úÖ AGGIORNATO: Mostra pulsante disconnessione e nascondi connessione
                document.getElementById('connectWallet').style.display = 'none';
                document.getElementById('disconnectWallet').style.display = 'inline-block';

                // ‚úÖ NUOVO: Mostra il pulsante backup quando connesso
                document.getElementById('backupKeypair').style.display = 'inline-block';

                walletInfoEl.innerHTML = `
                    <div style="font-weight: 600;">‚úì Wallet connected</div>
                    <div style="font-size: 0.8rem; margin-top: 2px;">${userAddress.slice(0, 6)}...${userAddress.slice(-4)}</div>
                `;

                keyPairStatusElement.innerHTML = `<span class="active">‚úì Keypair active</span>`;

                // ‚úÖ AGGIORNATO: I pulsanti di debug rimangono sempre visibili
                // Non √® pi√π necessario mostrare/nascondere i pulsanti di debug

                chatSection.style.display = 'block';

                // Load existing conversations from localStorage
                loadExistingConversations();

                // Set up message reception for all conversations
                setupMessageReception();
            } catch (error) {
                console.error("Error connecting to wallet:", error);
                alert("Error connecting to wallet. Check console for details.");
            }
        };

        // Function to load existing conversations from localStorage
        const loadExistingConversations = () => {
            // Load messages from localStorage
            loadMessagesFromLocalStorage();

            // Extract conversations from loaded messages
            Object.keys(chatMessages).forEach(conversationKey => {
                const messages = chatMessages[conversationKey];
                if (messages && messages.length > 0) {
                    // Extract the other address from conversation key
                    const addresses = conversationKey.split('_');
                    const otherAddress = addresses.find(addr =>
                        addr.toLowerCase() !== userAddress?.toLowerCase()
                    );

                    if (otherAddress) {
                        const lastMessage = messages[messages.length - 1];
                        const lastMessageContent = lastMessage.text || lastMessage.encryptedMSG || lastMessage.message || lastMessage.content || '';

                        addConversation(otherAddress, lastMessageContent, messages.length);
                    }
                }
            });
        };

        // Function to clean up duplicate messages
        const cleanDuplicateMessages = (messages) => {
            const seen = new Map();
            const cleaned = [];

            for (const message of messages) {
                const messageId = message.msg_id || `${message.from}_${message.date}_${message.text || message.encryptedMSG || message.message || message.content}`;

                if (!seen.has(messageId)) {
                    seen.set(messageId, true);
                    cleaned.push(message);
                } else {
                    console.log(`üîç Rimuovendo messaggio duplicato: ${messageId}`);
                }
            }

            return cleaned;
        };

        // Function to display a message in the chat
        const displayMessage = (message, isFromMe = false) => {
            // ‚úÖ NUOVO: Controllo per evitare che messaggi inviati vengano visualizzati come ricevuti
            if (!isFromMe && message.from && message.from.toLowerCase() === userAddress?.toLowerCase()) {
                console.log(`üîç Ignorando messaggio ricevuto che √® stato inviato da me: ${message.text || message.encryptedMSG || message.message || message.content}`);
                return;
            }

            // üîç MIGLIORATO: Controllo di deduplicazione pi√π robusto
            const messageId = message.msg_id || `${message.from}_${message.date}_${message.text || message.encryptedMSG || message.message || message.content}`;

            // Inizializza la mappa dei messaggi visualizzati se non esiste
            if (!window.displayedMessages) {
                window.displayedMessages = new Map();
            }

            // üîç NUOVO: Controllo pi√π aggressivo per messaggi duplicati
            // Se il messaggio ha lo stesso contenuto e mittente di un messaggio recente (ultimi 3 secondi), √® un duplicato
            const timeWindow = 3000; // 3 secondi
            const now = Date.now();
            const msgContent = message.text || message.encryptedMSG || message.message || message.content;
            const messageFrom = message.from && message.from.toLowerCase();

            // Controlla tutti i messaggi visualizzati recentemente per duplicati
            for (const [key, timestamp] of window.displayedMessages.entries()) {
                if (now - timestamp < timeWindow) {
                    // Se la chiave contiene lo stesso contenuto e mittente, √® un duplicato
                    if (key.includes(msgContent) && key.includes(messageFrom)) {
                        console.log(`üîç DUPLICATO FRONTEND: ${msgContent} da ${messageFrom} (gi√† visualizzato ${Math.round((now - timestamp) / 1000)}s fa)`);
                        return; // Ignora il messaggio duplicato
                    }
                }
            }

            // Controlla se il messaggio √® gi√† stato visualizzato
            if (window.displayedMessages.has(messageId)) {
                console.log(`üîç Messaggio gi√† visualizzato, ignorato: ${messageId}`);
                return;
            }

            // Marca il messaggio come visualizzato
            window.displayedMessages.set(messageId, Date.now());

            // Pulisci i messaggi vecchi (pi√π di 5 minuti)
            setTimeout(() => {
                if (window.displayedMessages) {
                    window.displayedMessages.delete(messageId);
                }
            }, 5 * 60 * 1000);

            const messageElement = document.createElement('div');
            messageElement.className = `message ${isFromMe ? 'sent' : 'received'}`;

            const timestamp = new Date(message.date || Date.now()).toLocaleTimeString();
            const sender = isFromMe ? 'You' : (message.from ? `${message.from.slice(0, 6)}...${message.from.slice(-4)}` : 'Unknown');

            // Get message content with better fallback handling
            let messageContent = '';
            if (message.text && message.text.trim()) {
                messageContent = message.text;
            } else if (message.encryptedMSG && message.encryptedMSG.trim()) {
                messageContent = message.encryptedMSG;
            } else if (message.message && message.message.trim()) {
                messageContent = message.message;
            } else if (message.content && message.content.trim()) {
                messageContent = message.content;
            } else {
                messageContent = 'Message content unavailable';
                // Debug information when content is unavailable
                if (window.d3?.debug?.logLevel === 'debug' || window.d3?.debug?.logLevel === 'verbose') {
                    console.warn('Message content unavailable. Message object:', {
                        hasText: !!message.text,
                        hasEncryptedMSG: !!message.encryptedMSG,
                        hasMessage: !!message.message,
                        hasContent: !!message.content,
                        messageKeys: Object.keys(message)
                    });
                }
            }

            messageElement.innerHTML = `
                <div class="message-header">
                    <span class="sender">${sender}</span>
                    <span class="timestamp">${timestamp}</span>
                </div>
                <div class="message-content">
                    ${messageContent}
                </div>
            `;

            // ‚úÖ NUOVO: Inserisci il messaggio in ordine cronologico
            const messageTimestamp = message.date || Date.now();
            const existingMessages = Array.from(messagesContainer.children);

            // Trova la posizione corretta per inserire il messaggio
            let insertIndex = existingMessages.length;
            for (let i = 0; i < existingMessages.length; i++) {
                const existingMessage = existingMessages[i];
                const existingTimestamp = existingMessage.dataset.timestamp || 0;

                if (messageTimestamp < existingTimestamp) {
                    insertIndex = i;
                    break;
                }
            }

            // Inserisci il messaggio nella posizione corretta
            if (insertIndex === existingMessages.length) {
                // Aggiungi alla fine se √® il messaggio pi√π recente
                messagesContainer.appendChild(messageElement);
            } else {
                // Inserisci prima del messaggio esistente
                const referenceNode = existingMessages[insertIndex];
                messagesContainer.insertBefore(messageElement, referenceNode);
            }

            // Aggiungi il timestamp come attributo data per facilitare l'ordinamento
            messageElement.dataset.timestamp = messageTimestamp;

            // Scroll to bottom only if the new message is the most recent
            if (insertIndex === existingMessages.length) {
                messagesContainer.scrollTop = messagesContainer.scrollHeight;
            }

            // ‚úÖ NUOVO: Controllo automatico per riordinare se necessario
            // Se il messaggio √® stato inserito in una posizione diversa dalla fine, 
            // potrebbe essere necessario riordinare tutti i messaggi
            if (insertIndex !== existingMessages.length && existingMessages.length > 10) {
                // Riordina solo se ci sono molti messaggi per evitare performance issues
                setTimeout(() => {
                    reorderMessages();
                }, 100);
            }

            // Add conversation to sidebar
            const otherAddress = isFromMe ? message.to : message.from;
            if (otherAddress && otherAddress !== userAddress) {
                addConversation(otherAddress, messageContent, 1);
            }

            // Save message to localStorage
            saveMessageToLocalStorage(message, isFromMe);
        };

        // Function to save message to localStorage
        const saveMessageToLocalStorage = (message, isFromMe) => {
            const otherAddress = isFromMe ? message.to : message.from;
            if (!otherAddress || otherAddress === userAddress) return;

            const conversationKey = [userAddress, otherAddress].sort().join('_');

            if (!chatMessages[conversationKey]) {
                chatMessages[conversationKey] = [];
            }

            // Add message to conversation history
            chatMessages[conversationKey].push({
                ...message,
                timestamp: message.date || Date.now()
            });

            // Keep only last 100 messages per conversation
            if (chatMessages[conversationKey].length > 100) {
                chatMessages[conversationKey] = chatMessages[conversationKey].slice(-100);
            }

            saveMessagesToLocalStorage();
        };

        // Function to set up message reception
        const setupMessageReception = async () => {
            if (!userAddress || !gunKeyPair) {
                console.error('Cannot setup message reception: missing user address or keypair');
                return;
            }

            try {
                // Set up a general message listener that will handle messages for any recipient
                const cleanup = await d3.receiveMessage(userAddress, (messageData) => {
                    console.log('Received message data:', messageData);

                    // ‚úÖ CORRETTO: Verifica che il messaggio non sia inviato da noi
                    if (messageData.isSentByMe) {
                        console.log('Ignoring message sent by me in general listener');
                        return;
                    }

                    // Format the message data for display
                    const formattedMessage = {
                        text: messageData.decrypted || 'Message content unavailable',
                        from: messageData.sender || messageData.originalData?.from || 'Unknown',
                        to: userAddress,
                        date: messageData.timestamp || messageData.originalData?.date || Date.now()
                    };

                    // Check if the message is for the current recipient
                    const currentRecipient = recipientAddressInput.value.trim();
                    if (currentRecipient && formattedMessage.from && formattedMessage.from.toLowerCase() === currentRecipient.toLowerCase()) {
                        displayMessage(formattedMessage, false);
                    }
                });

                console.log('Message reception setup completed');
            } catch (error) {
                console.error('Error setting up message reception:', error);
            }
        };

        // Function to handle recipient address changes
        const handleRecipientChange = async () => {
            const recipientAddress = recipientAddressInput.value.trim();
            if (recipientAddress && userAddress && gunKeyPair) {
                try {
                    // Set up specific listener for this recipient
                    const cleanup = await d3.receiveMessage(recipientAddress, (messageData) => {
                        console.log('Received message for current recipient:', messageData);

                        // ‚úÖ CORRETTO: Verifica che il messaggio non sia inviato da noi
                        if (messageData.isSentByMe) {
                            console.log('Ignoring message sent by me in recipient-specific listener');
                            return;
                        }

                        // Format the message data for display
                        const formattedMessage = {
                            text: messageData.decrypted || 'Message content unavailable',
                            from: messageData.sender || messageData.originalData?.from || 'Unknown',
                            to: userAddress,
                            date: messageData.timestamp || messageData.originalData?.date || Date.now()
                        };

                        displayMessage(formattedMessage, false);
                    });

                    console.log(`Message reception setup for recipient: ${recipientAddress}`);
                } catch (error) {
                    console.error('Error setting up recipient-specific message reception:', error);
                }
            }
        };

        // Event listeners
        connectWalletBtn.addEventListener('click', connectWallet);

        // Disconnect wallet button
        document.getElementById('disconnectWallet').addEventListener('click', disconnectWallet);

        // Refresh conversation button
        document.getElementById('refreshConversation').addEventListener('click', () => {
            refreshCurrentConversation();
        });

        // Register keypair button
        document.getElementById('registerKeypair').addEventListener('click', async () => {
            try {
                if (!userAddress || !gunKeyPair) {
                    alert("Please connect your wallet first.");
                    return;
                }

                const result = await d3.ensureKeypairRegistered();
                if (result) {
                    alert("Keypair registered successfully!");
                } else {
                    alert("Failed to register keypair. Check console for details.");
                }
            } catch (error) {
                console.error("Error registering keypair:", error);
                alert("Error registering keypair: " + error.message);
            }
        });

        // ‚úÖ NUOVO: Backup Keypair button
        document.getElementById('backupKeypair').addEventListener('click', () => {
            openBackupModal();
        });

        // ‚úÖ NUOVO: Restore Keypair button
        document.getElementById('restoreKeypair').addEventListener('click', () => {
            openRestoreModal();
        });

        // Debug Keypair button
        document.getElementById('debugKeypair').addEventListener('click', async () => {
            if (!userAddress) {
                alert("Please connect your wallet first.");
                return;
            }

            try {
                console.log("üîç Avviando debug keypair per:", userAddress);
                const status = await d3.debugKeypairStatus(userAddress);

                let message = `üîç DEBUG KEYPAIR STATUS\n\n`;
                message += `Address: ${status.address}\n`;
                message += `Is Current User: ${status.isCurrentUser}\n`;
                message += `Keypair in Memory: ${status.hasKeypairInMemory}\n`;
                message += `Keypair in Database: ${status.hasKeypairInDatabase}\n`;
                message += `Retrieved from DB: ${status.retrievedKeypair}\n\n`;

                if (status.memoryKeypair) {
                    message += `Memory Keypair:\n`;
                    message += `- Has Pub: ${status.memoryKeypair.hasPub}\n`;
                    message += `- Has Epub: ${status.memoryKeypair.hasEpub}\n\n`;
                }

                if (status.databaseKeypair) {
                    message += `Database Keypair:\n`;
                    message += `- Has Pub: ${status.databaseKeypair.hasPub}\n`;
                    message += `- Has Epub: ${status.databaseKeypair.hasEpub}\n`;
                }

                if (status.error) {
                    message += `\n‚ùå ERROR: ${status.error}`;
                }

                console.log("üîç Debug result:", status);
                alert(message);
            } catch (error) {
                console.error("Error debugging keypair:", error);
                alert("Error debugging keypair: " + error.message);
            }
        });

        // Clear All Messages button
        document.getElementById('clearAllMessages').addEventListener('click', clearAllMessages);

        sendMessageBtn.addEventListener('click', async () => {
            const message = messageInput.value.trim();
            const recipientAddress = recipientAddressInput.value.trim();

            if (!message || !recipientAddress) {
                alert("Please enter both a message and a recipient address.");
                return;
            }

            try {
                // Generate a unique message ID for deduplication
                const messageId = `msg_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`;

                // üîç NUOVO: Marca questo messaggio come "inviato localmente" per evitare duplicazioni
                if (!window.sentMessages) {
                    window.sentMessages = new Map();
                }
                window.sentMessages.set(messageId, {
                    content: message,
                    timestamp: Date.now(),
                    recipient: recipientAddress
                });

                // Display the sent message immediately for better UX
                const sentMessage = {
                    text: message,
                    from: userAddress,
                    to: recipientAddress,
                    date: Date.now(),
                    msg_id: messageId, // Add unique ID for deduplication
                    sent_locally: true // Flag to identify locally sent messages
                };
                displayMessage(sentMessage, true);

                // Add conversation to sidebar immediately
                addConversation(recipientAddress, message, 1);

                // Clear input immediately
                messageInput.value = '';

                // Try to send the message
                const result = await d3.sendmessage(message, [recipientAddress], gunKeyPair);

                if (result.sent) {
                    console.log('Message sent successfully:', result);

                    // Show warning if fallback mode was used
                    if (result.fallback) {
                        console.warn('Message sent in fallback mode:', result.warning);
                        // You can show a toast notification here if you want
                    }

                    // Message is already displayed above
                } else {
                    console.error('Failed to send message:', result.why);

                    // Check if it's a network connectivity issue
                    if (result.why && result.why.message && result.why.message.includes('network') ||
                        result.why && result.why.message && result.why.message.includes('connection')) {
                        // Store message offline for later delivery
                        handleOfflineMessageSending(message, recipientAddress);
                        alert("Network connection issue. Message stored offline for later delivery.");
                    } else {
                        alert("Error sending message: " + (result.why ? result.why.message || result.why : "Unknown error"));
                    }
                }
            } catch (error) {
                console.error("Error sending message:", error);

                // Check if it's a network connectivity issue
                if (error.message && (error.message.includes('network') || error.message.includes('connection'))) {
                    // Store message offline for later delivery
                    handleOfflineMessageSending(message, recipientAddress);
                    alert("Network connection issue. Message stored offline for later delivery.");
                } else {
                    alert("Error sending message: " + error.message);
                }
            }
        });

        messageInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                sendMessageBtn.click();
            }
        });

        // Log level event listener
        document.getElementById('logLevel').addEventListener('change', function (e) {
            const selectedLevel = e.target.value;
            if (window.d3 && window.d3.debug) {
                window.d3.debug.setLogLevel(selectedLevel);
                console.log(`[SHOGUN-D3] Log level changed to: ${selectedLevel}`);
            }
        });

        // Set default log level
        if (window.d3 && window.d3.debug) {
            const logLevelSelect = document.getElementById('logLevel');
            if (logLevelSelect) {
                const defaultLevel = logLevelSelect.value;
                window.d3.debug.setLogLevel(defaultLevel);
                console.log(`[SHOGUN-D3] Initial log level set to: ${defaultLevel}`);
            }
        }

        // Event listener for recipient address changes
        recipientAddressInput.addEventListener('change', handleRecipientChange);
        recipientAddressInput.addEventListener('blur', handleRecipientChange);

        // Check Gun status every 10 seconds
        setInterval(checkGunStatus, 10000);
        checkGunStatus();

        // Check for offline messages to retry every 30 seconds
        setInterval(async () => {
            const isConnected = await checkGunStatus();
            if (isConnected && gunKeyPair) {
                await retryOfflineMessages();
            }
        }, 30000);

        // Function to switch restore modal tabs
        const switchRestoreTab = (tabName) => {
            // Update tab buttons
            document.getElementById('restoreTabBackup').classList.remove('active');
            document.getElementById('restoreTabManual').classList.remove('active');
            document.getElementById(`restoreTab${tabName.charAt(0).toUpperCase() + tabName.slice(1)}`).classList.add('active');

            // Update tab content - use style.display instead of CSS classes
            const backupTab = document.getElementById('restoreBackupTab');
            const manualTab = document.getElementById('restoreManualTab');

            if (tabName === 'backup') {
                backupTab.style.display = 'block';
                manualTab.style.display = 'none';
            } else if (tabName === 'manual') {
                backupTab.style.display = 'none';
                manualTab.style.display = 'block';
            }
        };

        // Function to open backup modal
        const openBackupModal = () => {
            document.getElementById('backupModal').style.display = 'block';
        };

        // Function to close backup modal
        const closeBackupModal = () => {
            document.getElementById('backupModal').style.display = 'none';
            document.getElementById('backupData').value = '';
            document.getElementById('backupPassword').value = '';
        };

        // Function to open restore modal
        const openRestoreModal = () => {
            document.getElementById('restoreModal').style.display = 'block';
            // Reset to backup tab by default
            switchRestoreTab('backup');
        };

        // Function to close restore modal
        const closeRestoreModal = () => {
            document.getElementById('restoreModal').style.display = 'none';
            document.getElementById('restoreData').value = '';
            document.getElementById('restorePassword').value = '';
            document.getElementById('restorePub').value = '';
            document.getElementById('restorePriv').value = '';
            document.getElementById('restoreEpub').value = '';
            document.getElementById('restoreEpriv').value = '';
        };

        // Function to generate backup
        const generateBackup = async () => {
            if (!userAddress || !gunKeyPair) {
                alert("Please connect your wallet first.");
                return;
            }

            try {
                const password = document.getElementById('backupPassword').value;
                const backupData = await d3.backupKeypair(password);

                if (backupData) {
                    document.getElementById('backupData').value = JSON.stringify(backupData, null, 2);
                } else {
                    alert("Failed to generate backup. Check console for details.");
                }
            } catch (error) {
                console.error("Error generating backup:", error);
                alert("Error generating backup: " + error.message);
            }
        };

        // Function to download backup
        const downloadBackup = () => {
            const backupData = document.getElementById('backupData').value;
            if (!backupData.trim()) {
                alert("Please generate a backup first.");
                return;
            }

            const blob = new Blob([backupData], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `shogun-keypair-backup-${Date.now()}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        };

        // Function to copy backup to clipboard
        const copyBackupToClipboard = () => {
            const backupData = document.getElementById('backupData').value;
            if (!backupData.trim()) {
                alert("Please generate a backup first.");
                return;
            }

            navigator.clipboard.writeText(backupData).then(() => {
                alert("Backup data copied to clipboard!");
            }).catch(err => {
                console.error('Failed to copy: ', err);
                alert("Failed to copy to clipboard. Please copy manually.");
            });
        };

        // Function to load backup file
        const loadBackupFile = (event) => {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function (e) {
                document.getElementById('restoreData').value = e.target.result;
            };
            reader.readAsText(file);
        };

        // Function to clean and validate backup data
        const cleanBackupData = (data) => {
            // Remove any extra whitespace and newlines
            let cleaned = data.trim();

            // Remove any BOM characters
            cleaned = cleaned.replace(/^\uFEFF/, '');

            // If the data starts and ends with quotes, it might be a JSON string
            if (cleaned.startsWith('"') && cleaned.endsWith('"')) {
                try {
                    cleaned = JSON.parse(cleaned);
                } catch (e) {
                    // If it fails, keep the original
                }
            }

            return cleaned;
        };

        // Function to perform restore
        const performRestore = async () => {
            try {
                // Check which tab is active
                const activeTab = document.querySelector('.tab-button.active').id;

                let keypairData = null;

                if (activeTab === 'restoreTabBackup') {
                    // Restore from backup data
                    const backupData = document.getElementById('restoreData').value.trim();
                    const password = document.getElementById('restorePassword').value;

                    if (!backupData) {
                        alert("Please enter backup data.");
                        return;
                    }

                    try {
                        // ‚úÖ NUOVO: Pulisci i dati prima del parsing
                        const cleanedData = cleanBackupData(backupData);
                        console.log("üîç Original backup data:", backupData);
                        console.log("üîç Cleaned backup data:", cleanedData);

                        let parsedData;

                        // ‚úÖ NUOVO: Gestisci JSON doppio-encoded (stringhe con virgolette escaped)
                        try {
                            // Prima prova a parsare direttamente
                            parsedData = JSON.parse(cleanedData);
                            console.log("üîç Parsed data (direct):", parsedData);
                        } catch (firstError) {
                            console.log("üîç First parse failed:", firstError.message);
                            // Se fallisce, prova a parsare come stringa JSON
                            try {
                                parsedData = JSON.parse(JSON.parse(cleanedData));
                                console.log("üîç Parsed data (double):", parsedData);
                            } catch (secondError) {
                                console.log("üîç Second parse failed:", secondError.message);
                                throw new Error("Invalid JSON format. Please check your backup data.");
                            }
                        }

                        // ‚úÖ NUOVO: Gestisci sia il formato backup che il formato keypair diretto
                        let dataToRestore = parsedData;

                        console.log("üîç Checking data structure:", {
                            hasKeypair: !!parsedData.keypair,
                            hasPub: !!parsedData.pub,
                            hasPriv: !!parsedData.priv,
                            hasEpub: !!parsedData.epub,
                            hasEpriv: !!parsedData.epriv
                        });

                        // Se √® un keypair diretto, crea un oggetto backup wrapper
                        if (parsedData.pub && parsedData.priv && parsedData.epub && parsedData.epriv && !parsedData.keypair) {
                            console.log("üîç Creating backup wrapper for direct keypair");
                            dataToRestore = {
                                version: "1.0",
                                timestamp: Date.now(),
                                address: window.currentUserAddress,
                                keypair: parsedData
                            };
                        }

                        console.log("üîç Final data to restore:", dataToRestore);

                        const result = await d3.restoreKeypair(dataToRestore, password);
                        if (result) {
                            alert("Keypair restored successfully!");
                            closeRestoreModal();
                            return;
                        } else {
                            alert("Failed to restore keypair. Check console for details.");
                            return;
                        }
                    } catch (error) {
                        alert("Invalid backup data format: " + error.message);
                        return;
                    }
                } else if (activeTab === 'restoreTabManual') {
                    // Restore from manual input
                    const pub = document.getElementById('restorePub').value.trim();
                    const priv = document.getElementById('restorePriv').value.trim();
                    const epub = document.getElementById('restoreEpub').value.trim();
                    const epriv = document.getElementById('restoreEpriv').value.trim();

                    if (!pub || !priv || !epub || !epriv) {
                        alert("Please fill in all keypair fields.");
                        return;
                    }

                    // Create backup object structure from manual input
                    const backupData = {
                        version: "1.0",
                        timestamp: Date.now(),
                        address: window.currentUserAddress,
                        keypair: {
                            pub: pub,
                            priv: priv,
                            epub: epub,
                            epriv: epriv
                        }
                    };

                    // Try to restore using the manual keypair
                    try {
                        const result = await d3.restoreKeypair(backupData);
                        if (result) {
                            alert("Keypair restored successfully from manual input!");
                            closeRestoreModal();
                            return;
                        } else {
                            alert("Failed to restore keypair from manual input. Check console for details.");
                            return;
                        }
                    } catch (error) {
                        alert("Error restoring keypair from manual input: " + error.message);
                        return;
                    }
                }

                if (keypairData) {
                    alert("Keypair restored successfully!");
                    closeRestoreModal();
                } else {
                    alert("Failed to restore keypair. Check console for details.");
                }
            } catch (error) {
                console.error("Error performing restore:", error);
                alert("Error performing restore: " + error.message);
            }
        };

        // Function to populate fields with current keypair values
        const populateFromCurrentKeypair = () => {
            if (!window.gunKeyPair) {
                alert("No current keypair available. Please connect your wallet first.");
                return;
            }

            // Populate fields with current keypair values
            document.getElementById('restorePub').value = window.gunKeyPair.pub || '';
            document.getElementById('restorePriv').value = window.gunKeyPair.priv || '';
            document.getElementById('restoreEpub').value = window.gunKeyPair.epub || '';
            document.getElementById('restoreEpriv').value = window.gunKeyPair.epriv || '';

            alert("Current keypair values loaded! You can now copy and modify them as needed.");
        };
    </script>
</body>

</html>